<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Trigrams for Grandma</title>
  <!-- Preload modal images -->
<link rel="preload" as="image" href="demo_clue.png">
<link rel="preload" as="image" href="demo_grid.gif">
<link rel="preload" as="image" href="question-mark.svg">
<link rel="preload" as="image" href="stats-icon.svg">


<style>
  :root{
    --bg:#a9cdf3;
    --bubble:#fff;
    --ink:#0b0b0b;

    --w1:#fff3b3;   /* yellow */
    --w2:#cfe8ff;   /* blue */
    --ol:#c9f3d6;   /* green overlap */
    --bad:#ffc9d2;  /* red/pink warning */
    --submit:#F4D2FD;

    --kb-h:260px;
    --caret:rgba(0,0,0,.18);

    --clue-hint-gap:7px;
    --lift-msg:38px;
    --lift-hints:96px;
    --msg-drop:35px;
    --result-drop:32px;
    --badge-drop:72px;
  }

  *{ box-sizing:border-box; }

  html,body{
    height:100%;
    overflow:hidden;
    overscroll-behavior:none;
    background:var(--bg);
  }
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    color:var(--ink);
    text-align:center;
    -webkit-text-size-adjust:100%;
  }

/* prevent selection / tap highlight inside the app */
:is(.wrap,#wrap,#rotateOverlay,#hintsModal,#kbHost,.kbHost),
:is(.wrap,#wrap,#rotateOverlay,#hintsModal,#kbHost,.kbHost) *{
  -webkit-user-select:none;
  user-select:none;
  -webkit-touch-callout:none;
  -webkit-tap-highlight-color:transparent;
  touch-action:manipulation;
}

  html.has-kb, html.has-kb body{
  -webkit-touch-callout:none;
  -webkit-user-select:none;
  user-select:none;
  -webkit-tap-highlight-color:transparent;
}

html.has-kb .kbKey, 
html.has-kb .kbKey *{
  -webkit-touch-callout:none;
  -webkit-user-select:none;
  user-select:none;
  -webkit-user-drag:none;
  -webkit-tap-highlight-color:transparent;
}



  /* Smooth dim/blur transitions for main content + keyboard */
  :is(#wrap,.wrap,#kbHost,.kbHost){
    transition:filter .1s ease, opacity .1s ease;
  }



  /* ===== Layout ===== */
  :is(.wrap,#wrap){
    height:100dvh;
    max-height:100dvh;
    width:100%;
    max-width:980px;
    margin:0 auto;
    padding:12px 14px 14px;
    display:flex;
    flex-direction:column;
    align-items:stretch;
    justify-content:flex-start;
    overflow:hidden;
    position:relative;
  }

  .toprow{
    display:flex;
    justify-content:center;
    align-items:center;
    margin-top:2px;
    flex:0 0 auto;
  }

  .modePill{
    position:absolute;
    top:10px;
    right:14px;
    padding:4px 9px;
    border-radius:999px;
    font-size:11px;
    letter-spacing:.12em;
    text-transform:uppercase;
    background:rgba(255,255,255,.34);
    border:1px solid rgba(0,0,0,.12);
    color:rgba(0,0,0,.68);
    font-weight:700;
    opacity:.85;
    pointer-events:auto;
    cursor:pointer;
  }


  /* Top-left icon buttons */
  .statsBtn,
  .helpBtn{
    position:absolute;
    top:10px;
    width:28px;
    height:28px;
    border-radius:999px;
    padding:0;
    margin:0;
    background:rgba(255,255,255,.34);
    border:1px solid rgba(0,0,0,.12);
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    appearance:none;
    -webkit-appearance:none;
    outline:none;
    box-shadow:none;
  }
  .statsBtn{ left:14px; }
  .helpBtn{ left:48px; }

  .statsBtn:focus,
  .helpBtn:focus{
    outline:none;
    box-shadow:none;
  }
  .statsBtn:active,
  .helpBtn:active{
    transform:translateY(1px);
  }

  .statsIcon,
  .helpIcon{
    width:17px;
    height:17px;
    opacity:.50;
    display:block;
    pointer-events:none;
  }


  .nav{
    display:flex;
    align-items:center;
    gap:10px;
    font-weight:850;
  }
  .nav :is(a,button){
    color:var(--ink);
    text-decoration:none;
    font-weight:850;
    padding:5px 10px;
    border-radius:999px;
    background:rgba(255,255,255,.32);
    border:1.5px solid rgba(0,0,0,.16);
    cursor:pointer;
    appearance:none;
    -webkit-appearance:none;
    font:inherit;
  }
  .nav :is(a,button):active{ transform:translateY(1px); }
    .nav a.is-disabled{
    opacity:.35;
    pointer-events:none;
    cursor:default;
  }



.nav .navCaret{
  display:inline-block;
  position:relative;
  opacity:0.5;
  top:-1px; 
}


  .count{
    font-weight:850;
    opacity:.6;
    min-width:58px;
    text-align:center;
  }

  /* ===== Clue + floating hint track ===== */
  .clue{
    display:block;
    width:fit-content;
    max-width:min(940px,94vw);
    margin:clamp(18px,3.6vh,36px) auto 0;
    padding:14px 13px 15px 20px;
    background:var(--bubble);
    border-radius:18px;
    box-shadow:0 2px 6px rgba(0,0,0,.08);
    font-size:clamp(30px,5.4vw,38px);
    line-height:1.12;
    letter-spacing:.12px;
    font-weight:400;
    flex:0 0 auto;
  }

  /* ===== Assist activation flash (clue glow) ===== */
  .clue.assist-glow{ animation:assistClueGlow 3.2s ease-out both; }
  @keyframes assistClueGlow{
    0%{
      box-shadow:
        0 2px 6px rgba(0,0,0,.08),
        0 0 0 4px rgba(70,255,150,.95),
        0 0 40px rgba(70,255,150,.75);
    }
    55%{
      box-shadow:
        0 2px 6px rgba(0,0,0,.08),
        0 0 0 4px rgba(70,255,150,.72),
        0 0 54px rgba(70,255,150,.6);
    }
    100%{
      box-shadow:
        0 2px 6px rgba(0,0,0,.08),
        0 0 0 0 rgba(70,255,150,0),
        0 0 0 rgba(70,255,150,0);
    }
  }

  /* ===== Assist activation flash (message) ===== */
  .msg.assistFlash{ animation:assistMsgFlash 4.2s ease-in-out both; }
  @keyframes assistMsgFlash{
    0%   { opacity:0;   transform:translateX(-50%) translateY(-6px); }
    12%  { opacity:.92; transform:translateX(-50%) translateY(0); }
    75%  { opacity:.92; transform:translateX(-50%) translateY(0); }
    100% { opacity:0;   transform:translateX(-50%) translateY(10px); }
  }

  .clue .len{
    opacity:.55;
    display:inline-block;
    font-size:.92em;
    line-height:1;
    vertical-align:middle;
    position:relative;
    top:-0.1em;
    margin-left:8px;
  }

  .clueWrap{
    position:relative;
    flex:0 0 auto;
    padding-bottom:0;
  }
  .clueWrap.hasTopTrack{ padding-bottom:15px; }

  .hintTrackTop{
    position:absolute;
    left:50%;
    top:calc(100% + var(--clue-hint-gap));
    transform:translateX(-50%);
    margin:0;
    min-height:0;
    z-index:30;
  }

  .clueWord{
    display:inline-block;
    cursor:pointer;
    font-kerning:none;
    font-variant-ligatures:none;
    font-feature-settings:"kern" 0,"liga" 0,"clig" 0;
  }

  .u-w1,.u-w2,.u-red{
    text-decoration:underline;
    text-decoration-thickness:6px;
    text-underline-offset:9px;
    pointer-events:none;
  }
  .u-w1{ text-decoration-color:rgba(255,220,0,.9); }
  .u-w2{ text-decoration-color:rgba(70,160,255,.92); }
  .u-red{ text-decoration-color:rgba(235,80,92,.92); }

  /* ===== Grid ===== */
  :is(.gridDock,#gridDock){
    display:block;
    width:fit-content;
    margin:105px auto 0;
    position:relative;
    flex:0 0 auto;
    border-radius:14px;
    box-shadow:0 3px 8px rgba(0,0,0,.08);
    transition:box-shadow .45s ease;
    will-change:transform,box-shadow;
    z-index:20;
    isolation:isolate;
  }
  @media (pointer:coarse) and (max-width:920px){
    :is(.gridDock,#gridDock){ margin-top:clamp(36px,6.1vh,62px); }
  }
  html.has-kb :is(.gridDock,#gridDock){ margin:90px auto 0; }
  :is(.gridDock,#gridDock).shake{ animation:shake .16s linear 0s 2; }

  .wrap.solved:not(.gaveup) :is(.gridDock,#gridDock),
  .wrap.gaveup :is(.gridDock,#gridDock){
    pointer-events:none;
    transform:translate3d(0,-16px,0) scale(1.01);
    box-shadow:0 14px 26px rgba(0,0,0,.14);
    animation:solvedPop .46s ease-out both;
  }
  .wrap.solved:not(.gaveup) :is(.gridDock,#gridDock){
    box-shadow:
      0 0 0 7px rgba(200,247,210,.55),
      0 0 0 13px rgba(200,247,210,.22),
      0 14px 26px rgba(0,0,0,.14);
    animation:solvedPop .46s ease-out both, glowPulse 1.15s ease-in-out 0s 2;
  }
  .wrap.gaveup :is(.gridDock,#gridDock){
    box-shadow:
      0 0 0 7px rgba(255,150,160,.46),
      0 0 0 13px rgba(255,150,160,.20),
      0 14px 26px rgba(0,0,0,.14);
    animation:solvedPop .46s ease-out both, redPulse 1.15s ease-in-out 0s 2;
  }

  @keyframes solvedPop{
    0%{ transform:translate3d(0,-10px,0) scale(.985); }
    55%{ transform:translate3d(0,-20px,0) scale(1.02); }
    100%{ transform:translate3d(0,-16px,0) scale(1.01); }
  }
  @keyframes glowPulse{
    0%{
      box-shadow:
        0 0 0 7px rgba(200,247,210,.40),
        0 0 0 13px rgba(200,247,210,.16),
        0 14px 26px rgba(0,0,0,.14);
    }
    50%{
      box-shadow:
        0 0 0 7px rgba(200,247,210,.70),
        0 0 0 14px rgba(200,247,210,.28),
        0 16px 30px rgba(0,0,0,.16);
    }
    100%{
      box-shadow:
        0 0 0 7px rgba(200,247,210,.55),
        0 0 0 13px rgba(200,247,210,.22),
        0 14px 26px rgba(0,0,0,.14);
    }
  }
  @keyframes redPulse{
    0%{
      box-shadow:
        0 0 0 7px rgba(255,150,160,.32),
        0 0 0 13px rgba(255,150,160,.12),
        0 14px 26px rgba(0,0,0,.14);
    }
    50%{
      box-shadow:
        0 0 0 7px rgba(255,150,160,.60),
        0 0 0 14px rgba(255,150,160,.24),
        0 16px 30px rgba(0,0,0,.16);
    }
    100%{
      box-shadow:
        0 0 0 7px rgba(255,150,160,.46),
        0 0 0 13px rgba(255,150,160,.20),
        0 14px 26px rgba(0,0,0,.14);
    }
  }
  @keyframes shake{
    0%{ transform:translateX(0); }
    25%{ transform:translateX(-6px); }
    50%{ transform:translateX(6px); }
    75%{ transform:translateX(-4px); }
    100%{ transform:translateX(0); }
  }

  :is(.gridWrap,#gridWrap){
    display:block;
    border:4px solid var(--ink);
    border-radius:14px;
    overflow:hidden;
    background:#fff;
  }

  .grid{
    --n:7;
    --gap:3px;
    --cell:44px;
    display:grid;
    grid-template-columns:repeat(var(--n),1fr);
    gap:var(--gap);
    background:var(--ink);
    width:min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)),92vw);
  }

  .cell{
    aspect-ratio:1/1;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#fff;
    position:relative;
  }
  /* ===== Timed reveal mode scaffolding ===== */

/* Locked letter indicator: tiny corner triangle (minimal visual disruption) */
.cell.is-locked::before{
  content:"";
  position:absolute;
  top:0; right:0;
  width:0; height:0;
  border-top: 12px solid rgba(0,0,0,.18);
  border-left: 12px solid transparent;
  pointer-events:none;
}

/* Pink selectable reveal cells (only applies when JS adds the class) */
.cell.revealPickCell{
  background: var(--bad) !important;
  cursor:pointer;
  box-shadow: 0 0 0 2px rgba(0,0,0,.10) inset,
              0 0 0 3px rgba(241,89,130,.20);
}

/* Whole-board highlight while selecting a letter to reveal */
#wrap.revealPick :is(.gridDock,#gridDock){
  box-shadow:
    0 3px 8px rgba(0,0,0,.08),
    0 0 0 3px rgba(241,89,130,.55),
    0 0 0 7px rgba(241,89,130,.18);
}


  .cell.locked{
    background:linear-gradient(135deg, #fce8ff, #ffeef8);
    box-shadow:inset 0 0 0 2px rgba(0,0,0,.25);
  }
  .cell.locked input{
    color:rgba(0,0,0,.6);
  }

  .cell.hint-pink{
    background:#ffd3e6;
  }
  .cell.hint-highlight::before{
    content:"";
    position:absolute;
    inset:2px;
    border:2px dashed rgba(0,0,0,.32);
    border-radius:8px;
    pointer-events:none;
  }

  .cell.active::after{
    content:"";
    position:absolute;
    height:3px;
    width:62%;
    left:50%;
    bottom:12%;
    transform:translateX(-50%);
    background:var(--caret);
    border-radius:999px;
    animation:caretBlink 1.1s steps(2,end) infinite;
    pointer-events:none;
    opacity:1;
  }
  @keyframes caretBlink{
    0%,46%{ opacity:1; }
    47%,100%{ opacity:0; }
  }

  .cell input{
    width:100%;
    height:100%;
    border:0;
    outline:none;
    background:transparent;
    text-align:center;
    font-size:clamp(23px,5.1vw,32px);
    font-weight:900;
    font-style:italic;
    padding:0;
    margin:0;
    color:var(--ink);
    text-transform:lowercase;
    caret-color:transparent;
    cursor:text;
    appearance:none;
    -webkit-appearance:none;
    border-radius:0;
    user-select:none;
    -webkit-user-select:none;
  }
  .cell input::selection{ background:transparent; color:inherit; }

  .cell.bg-w1{ background:var(--w1); }
  .cell.bg-w2{ background:var(--w2); }
  .cell.bg-ol{ background:var(--ol); }
  .cell.bg-bad{ background:var(--bad) !important; }

  .cell.grabbable{ cursor:grab; }
  .cell.grabbable:active{ cursor:grabbing; }
  .cell.grabbable input{ pointer-events:none; cursor:grab; }

  html.has-kb .cell input{ pointer-events:none; }

  /* ===== Messages ===== */
  :is(.msgSlot,#msgSlot){
    position:relative;
    height:78px;
    width:100%;
    max-width:760px;
    margin:clamp(2px,.7vh,6px) auto 0;
    flex:0 0 auto;
    pointer-events:none;
    transform:translateY(calc(-1 * var(--lift-msg) + var(--msg-drop)));
  }
  .wrap.solved :is(.msgSlot,#msgSlot){ margin-top:clamp(0px,.4vh,4px); }

  .msg{
    position:absolute;
    left:50%;
    top:18px;
    margin:0;
    font-weight:900;
    opacity:0;
    transition:opacity .18s ease, transform .18s ease;
    font-style:italic;
    font-size:22px;
    pointer-events:none;
    width:max-content;
    max-width:min(92vw,760px);
    white-space:pre-line;
    line-height:1.15;
    text-align:center;
    transform:translateX(-50%) translateY(0);
    padding-right: 0.25em; 
  margin-right: -0.25em; 
  box-sizing: content-box;
  }
  .msg.show{ opacity:.92; }
  .msg.warn{ opacity:.92; font-size:20px; }
  .msg.result{
    top:12px;
    font-size:27px;
    transform:translateX(-50%) translateY(calc(var(--result-drop) - var(--msg-drop)));
  }

  .msg .msgLine{ display:block; }
  .msg.result .msgLine.score{ font-size:26px; margin-top:6px; }
  .msg.result .msgLine.meta{ font-size:14px; opacity:.55; margin-top:4px; }

  /* ===== Hint track + tiles ===== */
  :is(.hintTrack,#hintTrack){
    width:fit-content;
    max-width:min(920px,96vw);
    display:flex;
    align-items:center;
    justify-content:center;
    transition:opacity .35s ease, transform .35s ease;
  }

  .hintDockBottom{
    width:100%;
    max-width:920px;
    margin:8px auto 0;
    display:flex;
    justify-content:center;
    align-items:center;
    flex:0 0 auto;
    z-index:25;
    min-height:40px;
  }

  html.has-kb .hintDockBottom{
    position:fixed;
    left:0; right:0;
    bottom:calc(
      var(--kb-h) + env(safe-area-inset-bottom) + 36px
      + var(--btn-row-h, 0px) + 22px
    );
    margin:0;
    z-index:9996;
  }

  .trackRow{
    display:flex;
    align-items:flex-start;
    justify-content:center;
    gap:18px;
    flex-wrap:nowrap;
    transition:opacity .35s ease;
  }

  .trackBlock{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:6px;
    min-width:0;
  }

  .letters{
    display:inline-flex;
    background:transparent;
    position:relative;
    flex:0 0 auto;
  }
  .letters.clickable{ cursor:pointer; }

  .letter{
    width:29px;
    height:29px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-style:italic;
    font-size:19px;
    text-transform:lowercase;
    background:rgba(255,255,255,.35);
    transition:opacity .15s ease, background .15s ease, transform .08s ease;
    border:1px solid rgba(0,0,0,.22);
    transform-origin:center;
  }
  .letter + .letter{ margin-left:-1px; }

  .letter.sel-w1{ background:var(--w1); }
  .letter.sel-w2{ background:var(--w2); }

  .letter.extra{
    background:rgba(255,255,255,.95);
    cursor:pointer;
    box-shadow:none;
  }
  .letter.extra:active{ transform:translateY(1px); }

  .extrasRow{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:center;
    flex-wrap:nowrap;
  }

  .letters.is-in-grid .letter{ opacity:.38; }
  #trackBox-extras .letter.is-in-grid{ opacity:.38; }

  /* ===== Hint fly overlay ===== */
  .hintSpotOverlay{
    position:fixed;
    inset:0;
    z-index:12000;
    pointer-events:none;
    display:block;
  }
  .hintSpot{
    position:fixed;
    left:50%;
    top:42%;
    transform:translate(-50%,-50%);
    display:inline-flex;
    align-items:center;
    justify-content:center;
    will-change:transform,filter,opacity;
  }
  .hintSpot.h1 .letter{ background:var(--w1); }
  .hintSpot.h2 .letter{ background:var(--w2); }
  .hintSpot.hex .letter{ background:rgba(255,255,255,.97); }

  /* ===== Skill dock + badge ===== */
  :is(.skillDock,#skillDock){
    margin:clamp(0px,.5vh,6px) auto 0;
    width:fit-content;
    max-width:min(920px,96vw);
    min-height:74px;
    display:flex;
    align-items:center;
    justify-content:center;
    flex:0 0 auto;
    position:relative;
    transform:translateY(calc(-1 * var(--lift-hints)));
  }

  .wrap.solved .trackRow{ opacity:0; }
  .wrap.solved .hintTrack{ pointer-events:none; opacity:1; }

  .skillBadge{
    position:absolute;
    left:50%;
    top:40%;
    transform:translate(-50%,-50%) translateY(var(--badge-drop)) scale(.84);
    opacity:0;
    pointer-events:none;
    transition:opacity .35s ease, transform .35s ease;
  }
.wrap.solved .skillBadge{
  opacity:1;
  transform:translate(-50%,-50%) translateY(var(--badge-drop)) scale(.86);
  transition-delay:.06s;
  pointer-events:auto;
  cursor:pointer;
  -webkit-tap-highlight-color:transparent;
}


    .nextPuzzleBtn{
    position:absolute;
    left:50%;
    top:40%;

    /* increase this number for a bigger gap under the badge */
    --next-y: calc(var(--badge-drop) + 120px);

    transform:translate(-50%,-50%) translateY(var(--next-y));
    opacity:0;
    visibility:hidden;
    pointer-events:none;

    border:3.5px solid var(--ink);
    border-radius:999px;
    padding:9px 16px;
    min-width:190px;
    font-size:16px;
    font-weight:900;
    color:var(--ink);
    background:rgba(255,255,255,.35);
    cursor:pointer;
    text-transform:uppercase;
    letter-spacing:.12em;
    appearance:none;
    -webkit-appearance:none;
    box-shadow:0 7px 0 rgba(0,0,0,.16);
    transition:opacity .35s ease, transform .35s ease;
  }

  .nextPuzzleBtn:active{
    transform:translate(-50%,-50%) translateY(calc(var(--next-y) + 1px));
    box-shadow:0 6px 0 rgba(0,0,0,.16);
  }

  /* show it only once the answer is revealed (solved OR gave up) */
  .wrap.solved .nextPuzzleBtn,
  .wrap.gaveup .nextPuzzleBtn{
    opacity:1;
    visibility:visible;
    pointer-events:auto;
    transition-delay:.10s;
  }

  /* only apply disabled styling once it‚Äôs actually visible */
  .wrap.solved .nextPuzzleBtn:disabled,
  .wrap.gaveup .nextPuzzleBtn:disabled{
    opacity:.35;
    cursor:default;
    pointer-events:none;
  }

  .skillBadgeInner{
    position:relative;
    overflow:hidden;
    min-width:120px;
    padding:10px 14px;
    border-radius:16px;
    text-align:center;

    --txt:#2a1a00;
    --bdr:rgba(255,220,130,.65);
    --g1:rgba(255,235,180,.95);
    --g2:rgba(255,200,90,.92);
    --g3:rgba(255,240,200,.96);
    --g4:rgba(255,190,70,.92);

    color:var(--txt);
    border:1px solid var(--bdr);
    background:linear-gradient(135deg,var(--g1) 0%,var(--g2) 35%,var(--g3) 70%,var(--g4) 100%);
    box-shadow:
      0 12px 26px rgba(255,200,80,.16),
      0 3px 10px rgba(0,0,0,.22);
  }

  .skillBadgeInner.gold{
    --txt:#2a1a00;
    --bdr:rgba(255,220,130,.70);
    --g1:rgba(255,238,190,.96);
    --g2:rgba(255,205,105,.94);
    --g3:rgba(255,246,210,.97);
    --g4:rgba(255,185,70,.93);
    box-shadow:
      0 14px 28px rgba(255,205,95,.18),
      0 3px 10px rgba(0,0,0,.22);
  }

  .skillBadgeInner.silver{
    --txt:#1f2328;
    --bdr:rgba(200,206,215,.70);
    --g1:rgba(238,242,247,.99);
    --g2:rgba(214,222,232,.96);
    --g3:rgba(242,246,250,.99);
    --g4:rgba(203,212,223,.95);
    box-shadow:
      0 12px 24px rgba(0,0,0,.12),
      0 3px 10px rgba(0,0,0,.20);
  }

  .skillBadgeInner.bronze{
    --txt:#2a1204;
    --bdr:rgba(190,130,95,.46);
    --g1:rgba(248,214,190,.99);
    --g2:rgba(226,170,130,.96);
    --g3:rgba(250,222,205,.99);
    --g4:rgba(208,150,112,.95);
    box-shadow:
      0 12px 24px rgba(0,0,0,.12),
      0 3px 10px rgba(0,0,0,.20);
  }

  .skillBadgeInner.red{
    --txt:#160405;
    --bdr:rgba(150,55,60,.42);
    --g1:rgba(242,208,208,.99);
    --g2:rgba(220,150,148,.96);
    --g3:rgba(244,214,214,.99);
    --g4:rgba(195,120,120,.95);
    box-shadow:
      0 14px 28px rgba(0,0,0,.14),
      0 3px 10px rgba(0,0,0,.20);
  }

  .skillBadgeLabel{
    font-size:12px;
    font-weight:900;
    letter-spacing:.14em;
    text-transform:uppercase;
    opacity:.75;
  }
  .skillBadgeValue{
    font-size:34px;
    font-weight:950;
    line-height:1;
    margin-top:2px;
    text-shadow:0 1px 0 rgba(255,255,255,.45);
  }

  .skillBadgeInner::before{
    content:"";
    position:absolute;
    inset:0;
    border-radius:inherit;
    background:
      radial-gradient(circle at 18% 28%, rgba(255,255,255,.85), transparent 38%),
      radial-gradient(circle at 78% 42%, rgba(255,255,255,.55), transparent 42%),
      radial-gradient(circle at 54% 86%, rgba(255,255,255,.35), transparent 48%);
    opacity:.55;
    pointer-events:none;
  }
  .skillBadgeInner::after{
    content:"";
    position:absolute;
    inset:0;
    border-radius:inherit;
    pointer-events:none;
    background:linear-gradient(110deg,
      transparent 0%,
      rgba(255,255,255,0) 38%,
      rgba(255,255,255,.70) 48%,
      rgba(255,255,255,0) 60%,
      transparent 100%);
    background-size:220% 100%;
    background-position:-120% 0;
    opacity:.55;
    mix-blend-mode:soft-light;
    animation:skillShine 1.6s ease-in-out infinite;
  }
  @keyframes skillShine{
    0%{ background-position:-120% 0; opacity:0; }
    15%,55%{ opacity:.55; }
    100%{ background-position:120% 0; opacity:0; }
  }
  @media (prefers-reduced-motion:reduce){
    .skillBadgeInner::after{ animation-duration:4.5s; opacity:.25; }
  }

  /* ===== Buttons ===== */
  :is(.btnRow,#btnRow){
    margin-top:clamp(18px,3.8vh,26px);
    display:flex;
    justify-content:center;
    gap:12px;
    flex-wrap:wrap;
    flex:0 0 auto;
    padding-bottom:2px;
    transition:opacity .35s ease, transform .35s ease;
  }

  .wrap.solved :is(#btnRow,.btnRow){
    opacity:0;
    transform:translateY(6px);
    pointer-events:none;
  }
  .wrap.solved .hintTrackTop{ opacity:0; pointer-events:none; }

  .btn{
    border:4px solid var(--ink);
    border-radius:999px;
    padding:9px 16px;
    min-width:104px;
    font-size:20px;
    font-weight:900;
    font-style:italic;
    color:var(--ink);
    background:rgba(255,255,255,.35);
    cursor:pointer;
    text-transform:lowercase;
    appearance:none;
    -webkit-appearance:none;
    box-shadow:0 7px 0 rgba(0,0,0,.16);
  }
  .btn:active{ transform:translateY(1px); box-shadow:0 6px 0 rgba(0,0,0,.16); }
  /* Hint button can show a timed fill (used in timed-reveal mode) */
  .btn.hints{
    background:#fff3bd;
    position:relative;
    overflow:hidden;
  }
  .btn.hints::after{
    content:"";
    position:absolute;
    inset:0;
    background:linear-gradient(90deg, rgba(255,255,255,.85), rgba(255,210,253,.95));
    width:var(--hint-fill, 0%);
    pointer-events:none;
    transition:width .25s ease;
    z-index:0;
  }
  .btn.hints span{
    position:relative;
    z-index:1;
  }

  .btn.check{ background:rgba(255,255,255,.25); opacity:.55; }
  .btn.check.ready{ opacity:1; background:var(--submit); }
  .btn:disabled{
    opacity:.35 !important;
    cursor:default;
    transform:none !important;
    box-shadow:0 7px 0 rgba(0,0,0,.10);
  }

  html.has-kb :is(.btnRow,#btnRow){
    position:fixed;
    left:0; right:0;
    bottom:calc(var(--kb-h) + env(safe-area-inset-bottom) + 36px);
    margin:0;
    z-index:9997;
  }
  html.has-kb .btn{ border-width:3px; }

  /* ===== Ghost drag tile ===== */
  .ghost{
    position:fixed;
    z-index:9999;
    pointer-events:none;
    transform:translate(-50%,-50%);
    filter:drop-shadow(0 14px 16px rgba(0,0,0,.22));
    opacity:.95;
  }

  /* ===== Keyboard ===== */
:is(.kbHost,#kbHost){
  position:fixed;
  left:0; right:0;
  bottom:0;
  z-index:9996;
  display:none;
  padding:10px 10px calc(22px + env(safe-area-inset-bottom));
  background:rgba(255,255,255,.90);
  backdrop-filter:blur(10px);
  -webkit-backdrop-filter:blur(10px);
  border-top:2px solid rgba(0,0,0,.14);
  touch-action:none;
}

    html.has-kb :is(.kbHost,#kbHost){ display:block; }

  /* hide custom keyboard once the answer is revealed */
  #wrap.solved ~ :is(.kbHost,#kbHost),
  #wrap.gaveup ~ :is(.kbHost,#kbHost){
    display:none !important;
  }


  .kb{
    max-width:560px;
    margin:0 auto;
    display:flex;
    flex-direction:column;
    gap:8px;
    --keyW:clamp(28px,8.6vw,48px);
  }
  .kbRow{ display:flex; justify-content:center; gap:4px; }

  .kbKey{
    width:var(--keyW);
    height:48px;
    border:2px solid rgba(0,0,0,.16);
    border-radius:11px;
    background:rgba(255,255,255,.82);
    font-weight:700;
    font-style:normal;
    text-transform:none;
    font-size:18px;
    color:var(--ink);
    cursor:pointer;
        -webkit-touch-callout:none;
    -webkit-user-select:none;
    user-select:none;

  }
  .kbKey:active{ transform:translateY(1px); }

  .kbKey .kbIcon{
    width:24px;
    height:24px;
    display:block;
    margin:0 auto;
    pointer-events:none;
    user-select:none;
    -webkit-user-drag:none;
  }

  .kbKey.wide{ width:calc(var(--keyW) * 1.55); font-size:12px; font-weight:900; letter-spacing:.08em; padding:0; }
  .kbKey.enter{ font-size:11px; letter-spacing:.02em; }
  .kbKey.enter:not(.is-disabled){ background:rgba(0,0,0,.07); }

  .kbKey.delete{
    font-size:16.3px;
    letter-spacing:.03em;
    font-weight:750;
    background:rgba(0,0,0,.07);
  }
  .kbKey.reset{
    font-size:13px;
    color:rgba(0,0,0,.6);
    letter-spacing:.01em;
    font-weight:700;
    background:rgba(0,0,0,.07);
  }

  .kbKey.is-disabled{
    opacity:.38;
    background:rgba(0,0,0,.04);
    border-color:rgba(0,0,0,.10);
    transform:none !important;
    cursor:default;
  }

/* ===== Modal + Stats overlay (shared) ===== */
  :is(.modalOverlay,.statsOverlay){
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.26);
    display:none;
    align-items:flex-start;  /* anchor cards near top */
    justify-content:center;
    padding:
      max(48px, env(safe-area-inset-top) + 65px) /* fixed-ish top gap */
      14px
      14px;
  }
  .modalOverlay{ z-index:10000; }
  .statsOverlay{ z-index:11000; }
  :is(.modalOverlay,.statsOverlay).open{ display:flex; }


  :is(.modalCard,.statsCard){
    width:min(420px,94vw);
    max-height:75vh;                 /* cap at 75% of viewport height */
    background:#fff;
    border-radius:18px;
    border:2px solid rgba(0,0,0,.15);
    box-shadow:0 10px 26px rgba(0,0,0,.18);
    overflow:hidden;                 /* header fixed, body scrolls */
    text-align:left;
    display:flex;                    /* header + body as flex column */
    flex-direction:column;
  }


:is(.modalHdr,.statsHdr){
  display:flex;
  align-items:center;
  justify-content:space-between;
  border-bottom:1px solid rgba(0,0,0,.08);
  gap:10px;
}
.modalHdr{ padding:14px 14px 12px; }
.statsHdr{ padding:14px 14px 10px; }


  .modalTitle,
  .statsTitle{
    font-weight:950;
    font-size:18px;
    letter-spacing:.01em;
  }
  .modalTitle{
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  :is(.modalX,.statsX){
    border:0;
    background:transparent;
    color:var(--ink);
    font-size:20px;
    line-height:1;
    font-weight:300;
    cursor:pointer;
    padding:2px 6px;
    opacity:.9;
    outline:none !important;
    box-shadow:none !important;
    appearance:none;
    -webkit-appearance:none;
  }
  :is(.modalX,.statsX):active{ transform:translateY(1px); }

:is(.modalBody,.statsBody){
  padding:12px 14px 14px;
  flex:1 1 auto;
  min-height:0;
  overflow:auto;
}
.statsBody{ font-size:14px; }



  .statsIntro{ margin-bottom:10px; font-size:13px; opacity:.8; }
  .statsSection{ margin-bottom:14px; }
  .statsSection h3{ margin:0 0 4px; font-size:15px; }
  .statsSummary{ margin:0 0 6px; font-size:13px; opacity:.85; }
  .statsCols{ display:flex; gap:10px; flex-wrap:wrap; }
  .statsCol{ flex:1 1 0; min-width:0; }
  .statsCol h4{
    margin:0 0 4px;
    font-size:12px;
    text-transform:uppercase;
    letter-spacing:.09em;
    opacity:.7;
  }

    .helpModeLink{
    margin-top:8px;
  }

  .linkBtn{
    border:0;
    padding:0;
    margin:0;
    background:none;
    color:#1a4ed8;
    font:inherit;
    text-decoration:underline;
    cursor:pointer;
  }
  .linkBtn:active{
    transform:translateY(1px);
  }


  .statRow{ display:flex; align-items:center; gap:6px; margin-bottom:3px; }
  .statLabel{ flex:0 0 64px; font-size:12px; opacity:.8; }
  .statBar{
    flex:1 1 auto;
    height:7px;
    border-radius:999px;
    background:rgba(0,0,0,.06);
    overflow:hidden;
  }
  .statBarFill{
    display:block;
    height:100%;
    border-radius:999px;
    background:linear-gradient(90deg, rgba(40,120,255,.9), rgba(110,200,255,.9));
  }
  .statValue{ flex:0 0 auto; min-width:18px; text-align:right; font-size:12px; }
  .statsEmpty{ margin:0 0 4px; font-size:13px; opacity:.75; }

  /* Dim + blur main content + keyboard whenever a modal/stats overlay is open */
  body:has(.modalOverlay.open) :is(#wrap,.wrap,#kbHost,.kbHost),
  body:has(.statsOverlay.open) :is(#wrap,.wrap,#kbHost,.kbHost){
    filter:blur(1px) brightness(0.9);
    opacity:.65;
  }


  
  /* ===== Rotate overlay ===== */
  #rotateOverlay{
    display:none;
    position:fixed;
    inset:0;
    z-index:25000;
    background:rgba(169,205,243,.98);
    padding:
      calc(18px + env(safe-area-inset-top))
      16px
      calc(18px + env(safe-area-inset-bottom));
    align-items:center;
    justify-content:center;
    text-align:center;
  }
  #rotateOverlay .card{
    width:min(560px,92vw);
    background:rgba(255,255,255,.92);
    border:2px solid rgba(0,0,0,.16);
    border-radius:18px;
    padding:18px 16px;
    box-shadow:0 10px 26px rgba(0,0,0,.18);
  }
  #rotateOverlay .title{
    margin:0 0 8px;
    font-weight:600;
    font-style:normal;
    font-size:16px;
    line-height:1.2;
    opacity:.78;
  }
  #rotateOverlay .body{
    margin:0;
    font-weight:950;
    font-size:24px;
    line-height:1.15;
  }
  #rotateOverlay .body b{ font-weight:inherit; }

  @media (pointer:coarse) and (orientation:landscape) and (max-height:430px){
    #rotateOverlay{ display:flex; }
    :is(#wrap,.wrap){ pointer-events:none; opacity:.25; filter:blur(2px); }
    :is(#kbHost,.kbHost){ display:none !important; }
    #hintsModal{ display:none !important; }
  }

  /* ===== Mobile tweaks ===== */
  @media (max-width:520px){
    :root{ --lift-msg:34px; --lift-hints:88px; }

    .nav :is(a,button){ padding:4px 9px; }

    .clue{
      font-size:clamp(33px,6.9vw,39px);
      margin-top:clamp(16px,3.4vh,28px);
    }

    .grid{
      --cell:43px;
      width:min(calc(var(--n) * var(--cell) + (var(--n) - 1) * var(--gap)),94vw);
    }
    .cell input{ font-size:clamp(24px,6.05vw,36px); }
    .letter{ width:28px; height:28px; font-size:19px; }

    .msgSlot{ height:84px; }
    .msg{ top:12px; font-size:20px; }
    .msg.warn{ font-size:19px; }
    .msg.result{ top:14px; font-size:25px; }

    .btn{ font-size:19px; padding:9px 15px; min-width:98px; }
    .kbKey{ height:46px; }
    .hintSpot{ top:40%; }

    .modePill{ top:8px; right:10px; font-size:10px; padding:3px 8px; }
    .statsBtn{ left:10px; top:8px; width:26px; height:26px; }
    .helpBtn{ left:44px; top:8px; width:26px; height:26px; }
  }

  @media (min-width:600px){
    .modePill{ right:calc(50% - 300px + 12px); }
    .statsBtn{ left:calc(50% - 300px + 12px); }
    .helpBtn{ left:calc(50% - 300px + 46px); }
  }


  /* Stats overlay typography boost */
.statsTitle{
  font-size: 1.4rem;         /* bigger, ‚Äúheadliney‚Äù */
  font-weight: 700;
}

.statsSection h3{
  font-size: 1.05rem;
  font-weight: 600;
}

.statsSummary{
  font-size: 0.98rem;        /* up from typical body size */
  line-height: 1.45;
}

.statsEmpty,
.statsIntro{
  font-size: 0.95rem;
  line-height: 1.5;
}


.statsModes{
  display:flex;
  flex-direction:column;
  gap:10px;
  margin-top:2px;
}

.statsSection{
  margin:0;
  padding:9px 11px 9px;
  border-radius:12px;
  background:rgba(0,0,0,.03);
  border:1px solid rgba(0,0,0,.06);
}

.statsSection-empty{
  background:transparent;
  border-style:dashed;
  border-color:rgba(0,0,0,.14);
}

.modeHeading{
  margin:0 0 6px;
  font-size: 1.4rem;     
  font-weight: 700;
  display:flex;
  align-items:baseline;
  gap:4px;
}

.modeMeta{
  font-size:0.80rem;
  font-weight:500;
  opacity:.72;
}

.modeLine{
  margin:1px 0;
  font-size:0.9rem;
  display:flex;
  gap:6px;
}

.modeLabel{
  flex:0 0 170px; /* wider so "Longest 0-hint streak:" stays on one line */
  font-weight:600;
  opacity:.78;
}

.modeValue{
  flex:1 1 auto;
}

.modeLine-muted,
.modeValue-muted{
  color:rgba(0,0,0,.40);
  opacity:.9;
}

.statsEmpty{
  margin:4px 0 2px;
  font-size:0.9rem;
  color:rgba(0,0,0,.55);
}
.helpDemos{
  max-width:500px;
  margin:10px auto 10px;
}
.helpDemos img{
  display:block;
  width:75%;
  height:auto;
  margin:0 auto;          
}

.helpDemos img + img{ margin-top:8px; }
  
</style>



</head>

<body>
  <div class="wrap" id="wrap">

       <!-- Stats button -->
    <button class="statsBtn" id="statsBtn" type="button" aria-label="Show stats">
      <img src="stats-icon.svg" alt="" class="statsIcon">
    </button>

    <!-- How-to-play button -->
    <button class="helpBtn" id="helpBtn" type="button" aria-label="How to play">
      <img src="question-mark.svg" alt="" class="helpIcon">
    </button>
    
    <div class="toprow">
    <div class="nav">
  <a href="#" id="prevBtn" aria-label="Previous puzzle">
    <span class="navCaret">‚Äπ</span>
  </a>
  <span class="count" id="count"></span>
  <a href="#" id="nextBtn" aria-label="Next puzzle">
    <span class="navCaret">‚Ä∫</span>
  </a>
</div>

    </div>
<div class="modePill" id="modePill" aria-label="Mode: Classic">Classic</div>
    
     <div class="clueWrap" id="clueWrap">
    <div class="clue" id="clue"></div>

    <!-- floating hint track UNDER the clue -->
    <div class="hintTrack hintTrackTop" id="hintTrack" aria-label="Hint tracker">
      <div class="trackRow" id="trackRow">
        <div class="trackBlock" id="trackW1"></div>
        <div class="trackBlock" id="trackW2"></div>
        <div class="trackBlock" id="trackExtras"></div>
      </div>
    </div>
  </div>

  <div class="gridDock" id="gridDock">
    <div class="gridWrap" id="gridWrap" aria-label="Answer grid">
      <div class="grid" id="grid" style="--n:7"></div>
    </div>
  </div>

  <div class="msgSlot" id="msgSlot" aria-live="polite">
    <div class="msg" id="msg"></div>
  </div>

<!-- Skill badge  -->
  <div class="skillDock" id="skillDock" aria-label="Skill badge">
    <div class="skillBadge" id="skillBadge" aria-hidden="true">
      <div class="skillBadgeInner">
        <div class="skillBadgeLabel">Skill</div>
        <div class="skillBadgeValue" id="skillBadgeValue">‚Äî</div>
      </div>
    </div>

    <button class="nextPuzzleBtn" id="nextPuzzleBtn" type="button" aria-label="Next puzzle">NEXT PUZZLE</button>
  </div>

  <!-- bottom hint-track dock (we move #hintTrack here when there‚Äôs room) -->
  <div class="hintDockBottom" id="hintDockBottom"></div>

  <div class="btnRow" id="btnRow">
    <button class="btn hints" id="hintsBtn" type="button">hint 1</button>
    <button class="btn check" id="checkBtn" type="button">check</button>
  </div>
</div>


  <div class="modalOverlay" id="hintsModal" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="hintsModalTitle">
      <div class="modalHdr">
        <div class="modalTitle" id="hintsModalTitle">Choose a hint</div>
        <button class="modalX" id="hintsModalClose" type="button" aria-label="Close">√ó</button>
      </div>
      <div class="modalBody" id="hintsModalBody"></div>
    </div>
  </div>
<!-- How to play modal -->
<div class="modalOverlay" id="helpOverlay" aria-hidden="true">
  <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="helpTitle">
    <div class="modalHdr">
      <div class="modalTitle" id="helpTitle">How to play</div>
      <button class="modalX" id="helpClose" type="button" aria-label="Close how to play">√ó</button>
    </div>
    <div class="modalBody" id="helpBody">
      <p>
        Each puzzle has <strong>two clue words</strong> and a
        <strong>unique 7-letter answer word</strong>.
      </p>
      <p>
        The answer word must contain <strong>one 3-letter chunk</strong> (a
        <em>trigram</em>) from <strong>each clue word</strong>.
         </p>
      <p>
        The two trigrams may <strong>overlap by 1-letter</strong>, so you‚Äôll need
        <strong>1 or 2 extra letters</strong> to make the word.
      </p>
            <div class="helpDemos" aria-label="Demo images">
        <img src="demo_grid.gif" alt="Grid demo" loading="eager" decoding="async">
      </div>

      <p>
        Maximise your <strong>skill score</strong> by taking fewer hints, less time and less wrong guesses!
      </p><hr style="border:0; height:1px; background:rgba(0,0,0,.1); margin:14px 0 16px;">


            <p class="helpModeLink">
        <strong>Classic mode</strong> - you do all the thinking and typing.</br></br>
        <strong>Assisted mode</strong> - tap a clue word to add or replace a trigram.
    </br></br>
        <button id="helpModeLearnMore" class="linkBtn" type="button">
          Learn more
        </button>
      </p>
    </div>
  </div>
</div>


  <!-- Mode info modal -->
  <div class="modalOverlay" id="modeOverlay" aria-hidden="true">
    <div class="modalCard" role="dialog" aria-modal="true" aria-labelledby="modeTitle">
      <div class="modalHdr">
                <div class="modalTitle" id="modeTitle">Game Modes</div>
        <button class="modalX" id="modeClose" type="button" aria-label="Close mode info">√ó</button>
      </div>
      <div class="modalBody" id="modeBody">
        <p>
          Puzzles always start in <strong>Classic mode</strong>. You have to do most of the thinking.
          You can still use hints and drag trigrams around the grid, but you can't quickly replace trigrams without typing.
        </p> <p><i>üß† Best mode to challenge your brain</i> </p><hr style="border:0; height:1px; background:rgba(0,0,0,.1); margin:14px 0 16px;">
        <p>
          <strong>Assisted mode</strong> <br><br>Simply tap a clue word at any time to turn this on for the current puzzle.
    
        </p>
        <ul>
          <li>Tap a clue word to add/replace trigrams</li>
          <li>Auto-highlighting of trigrams</li>
         
        </ul><p>  <i>üí° Best mode when you're feeling lazy</i> </p><hr style="border:0; height:1px; background:rgba(0,0,0,.1); margin:14px 0 16px;">
        <p>
          Your <strong>skill score</strong> and other stats will be tracked separately for Classic vs Assisted puzzle attempts to keep things fair.
        </p>
      </div>

    </div>
  </div>

  <div class="kbHost" id="kbHost" aria-label="On-screen keyboard"></div>


  <!-- Stats overlay -->
  <div class="statsOverlay" id="statsOverlay" aria-hidden="true">
    <div class="statsCard" role="dialog" aria-modal="true" aria-labelledby="statsTitle">
      <div class="statsHdr">
        <div class="statsTitle" id="statsTitle">Your stats</div>
        <button class="statsX" id="statsClose" type="button" aria-label="Close stats">√ó</button>
      </div>
      <div class="statsBody" id="statsBody"></div>
    </div>
  </div>

  <div id="rotateOverlay" aria-hidden="true">
    <div class="card" role="alert">
      <p class="body"><b>Please rotate your device.</b></p>
      <p class="title">Oops! We can't fit everything on your screen.</p>
    </div>
  </div>



<script>
/* =======================
   Puzzles
   ======================= */
const PUZZLES = [
{ clue:"Ample bounty", word1:"ample", word2:"bounty", answer:"aplenty", tri1:"ple", tri2:"nty" },
  { clue:"Vegans' picnic", word1:"vegans", word2:"picnic", answer:"organic", tri1:"gan", tri2:"nic" },
  { clue:"Wheezy groans", word1:"wheezy", word2:"groans", answer:"banshee", tri1:"hee", tri2:"ans" },
  { clue:"Absurd dream", word1:"absurd", word2:"dream", answer:"surreal", tri1:"sur", tri2:"rea" },
  { clue:"Summer sunset", word1:"summer", word2:"sunset", answer:"immense", tri1:"mme", tri2:"nse" },
  { clue:"Puzzles granny", word1:"puzzles", word2:"granny", answer:"rankles", tri1:"les", tri2:"ran" },
  { clue:"Custom jigsaw", word1:"custom", word2:"jigsaw", answer:"sawdust", tri1:"ust", tri2:"saw" },
  { clue:"Fresh socks", word1:"fresh", word2:"socks", answer:"restock", tri1:"res", tri2:"ock" },
  { clue:"Rotten tycoon!", word1:"rotten", word2:"tycoon", answer:"boycott", tri1:"ott", tri2:"yco" },
  { clue:"Butch alien", word1:"butch", word2:"alien", answer:"halibut", tri1:"but", tri2:"ali" },
  { clue:"Pancake ordeal", word1:"pancake", word2:"ordeal", answer:"deadpan", tri1:"pan", tri2:"dea" },
  { clue:"Embrace rawness", word1:"embrace", word2:"rawness", answer:"braless", tri1:"bra", tri2:"ess" },
  { clue:"Trucker reunion", word1:"trucker", word2:"reunion", answer:"ruction", tri1:"ruc", tri2:"ion" },
  { clue:"Bamboo catalog", word1:"bamboo", word2:"catalog", answer:"logbook", tri1:"boo", tri2:"log" },
  { clue:"Pesky waiver", word1:"pesky", word2:"waiver", answer:"skydive", tri1:"sky", tri2:"ive" },
  { clue:"Pasta sarcasm", word1:"pasta", word2:"sarcasm", answer:"starchy", tri1:"sta", tri2:"arc" },
  { clue:"Cheeky bishop!", word1:"cheeky", word2:"bishop", answer:"cherish", tri1:"che", tri2:"ish" },
  { clue:"Emotion robbed", word1:"emotion", word2:"robbed", answer:"robotic", tri1:"oti", tri2:"rob" },
  { clue:"Coffee breath", word1:"coffee", word2:"breath", answer:"offbeat", tri1:"off", tri2:"eat" },
  { clue:"Divorce payment", word1:"divorce", word2:"payment", answer:"percent", tri1:"rce", tri2:"ent" },
  { clue:"Hippo's radius", word1:"hippos", word2:"radius", answer:"adipose", tri1:"pos", tri2:"adi" },
  { clue:"Popular encore", word1:"popular", word2:"encore", answer:"popcorn", tri1:"pop", tri2:"cor" },
  { clue:"Campus admirer", word1:"campus", word2:"admirer", answer:"vampire", tri1:"amp", tri2:"ire" },
  { clue:"Apple drama", word1:"apple", word2:"drama", answer:"trample", tri1:"ple", tri2:"ram" },
  { clue:"Modify image", word1:"modify", word2:"image", answer:"magnify", tri1:"ify", tri2:"mag" },
  { clue:"Karaoke wonder", word1:"karaoke", word2:"wonder", answer:"parader", tri1:"ara", tri2:"der" },
  { clue:"Curious mailman", word1:"curious", word2:"mailman", answer:"curtail", tri1:"cur", tri2:"ail" },
  { clue:"Atomic secrets", word1:"atomic", word2:"secrets", answer:"creator", tri1:"ato", tri2:"cre" },
  { clue:"Incense factory", word1:"incense", word2:"factory", answer:"sensory", tri1:"ens", tri2:"ory" },
  { clue:"Crafty madame", word1:"crafty", word2:"madame", answer:"macrame", tri1:"cra", tri2:"ame" },
  { clue:"Jinxed bonbon", word1:"jinxed", word2:"bonbon", answer:"unboxed", tri1:"xed", tri2:"nbo" },
  { clue:"Laundry cleaner", word1:"laundry", word2:"cleaner", answer:"mundane", tri1:"und", tri2:"ane" },
  { clue:"Wholly muscle?", word1:"wholly", word2:"muscle", answer:"mollusc", tri1:"oll", tri2:"usc" },
  { clue:"Stupid gossip", word1:"stupid", word2:"gossip", answer:"insipid", tri1:"pid", tri2:"sip" },
  { clue:"Winter weaver", word1:"winter", word2:"weaver", answer:"sweater", tri1:"ter", tri2:"wea" },
  { clue:"Shark pontoon", word1:"shark", word2:"pontoon", answer:"harpoon", tri1:"har", tri2:"oon" },
  { clue:"Koalas launch!", word1:"koalas", word2:"launch", answer:"unclasp", tri1:"las", tri2:"unc" },
  { clue:"Junior minds", word1:"junior", word2:"minds", answer:"minions", tri1:"nio", tri2:"min" },
  { clue:"Library trolley", word1:"library", word2:"trolley", answer:"braille", tri1:"bra", tri2:"lle" },
  { clue:"Bikini weather!", word1:"bikini", word2:"weather", answer:"gherkin", tri1:"kin", tri2:"her" },
  { clue:"Savage queens", word1:"savage", word2:"queens", answer:"teenage", tri1:"age", tri2:"een" },
  { clue:"Pursue beauty", word1:"pursue", word2:"beauty", answer:"auteurs", tri1:"urs", tri2:"aut" },
  { clue:"Toasted success!", word1:"toasted", word2:"success", answer:"hostess", tri1:"ste", tri2:"ess" },
  { clue:"Beyond cryptic", word1:"beyond", word2:"cryptic", answer:"cryonic", tri1:"yon", tri2:"cry" },
  { clue:"Axolotl anarchy", word1:"axolotl", word2:"anarchy", answer:"blotchy", tri1:"lot", tri2:"chy" },
  { clue:"Thorny upstart", word1:"thorny", word2:"upstart", answer:"warthog", tri1:"tho", tri2:"art" },
  { clue:"Inane hiccup?", word1:"inane", word2:"hiccup", answer:"chicane", tri1:"ane", tri2:"hic" },
  { clue:"Podcast blunder", word1:"podcast", word2:"blunder", answer:"astound", tri1:"ast", tri2:"und" },
  { clue:"Titanic struck!", word1:"titanic", word2:"struck", answer:"tantrum", tri1:"tan", tri2:"tru" },
  { clue:"Damaged thumbs", word1:"damaged", word2:"thumbs", answer:"umbrage", tri1:"age", tri2:"umb" },
  { clue:"Monthly malice", word1:"monthly", word2:"malice", answer:"alimony", tri1:"mon", tri2:"ali" },
  { clue:"Switch phones", word1:"switch", word2:"phones", answer:"witness", tri1:"wit", tri2:"nes" },
  { clue:"Tamed debate", word1:"tamed", word2:"debate", answer:"mediate", tri1:"med", tri2:"ate" },
  { clue:"Lonely Martian", word1:"lonely", word2:"martian", answer:"elysian", tri1:"ely", tri2:"ian" },
  { clue:"Raunchy truth", word1:"raunchy", word2:"truth", answer:"uncouth", tri1:"unc", tri2:"uth" },
  { clue:"Nearly walked", word1:"nearly", word2:"walked", answer:"sneaked", tri1:"nea", tri2:"ked" },
  { clue:"Hazard symbol", word1:"hazard", word2:"symbol", answer:"bollard", tri1:"ard", tri2:"bol" },
  { clue:"Perform, monkey!", word1:"perform", word2:"monkey", answer:"hormone", tri1:"orm", tri2:"mon" },
  { clue:"Further charges", word1:"further", word2:"charges", answer:"harsher", tri1:"her", tri2:"har" },
  { clue:"Excess whiskey", word1:"excess", word2:"whiskey", answer:"keyless", tri1:"ess", tri2:"key" },
  { clue:"Ukulele museum", word1:"ukulele", word2:"museum", answer:"useless", tri1:"ele", tri2:"use" },
  { clue:"Macho spandex", word1:"macho", word2:"spandex", answer:"panache", tri1:"ach", tri2:"pan" },
  { clue:"Chaotic grandma", word1:"chaotic", word2:"grandma", answer:"frantic", tri1:"tic", tri2:"ran" },
  { clue:"Ninety friends", word1:"ninety", word2:"friends", answer:"variety", tri1:"ety", tri2:"rie" },
  { clue:"Forged ballot", word1:"forged", word2:"ballot", answer:"alleged", tri1:"ged", tri2:"all" },
  { clue:"Better apology", word1:"better", word2:"apology", answer:"politer", tri1:"ter", tri2:"pol" },
  { clue:"Grabbed hummus", word1:"grabbed", word2:"hummus", answer:"thumbed", tri1:"bed", tri2:"hum" },
  { clue:"Woven lullaby", word1:"woven", word2:"lullaby", answer:"novella", tri1:"ove", tri2:"lla" },
  { clue:"Smooth haptic", word1:"smooth", word2:"haptic", answer:"osmotic", tri1:"smo", tri2:"tic" },
  { clue:"Artisan cakes", word1:"artisan", word2:"cakes", answer:"partake", tri1:"art", tri2:"ake" },
  { clue:"Heroic abandon", word1:"heroic", word2:"abandon", answer:"android", tri1:"roi", tri2:"and" },
  { clue:"Toilet jostle!", word1:"toilet", word2:"jostle", answer:"hostile", tri1:"ile", tri2:"ost" },
  { clue:"Circus target", word1:"circus", word2:"target", answer:"custard", tri1:"cus", tri2:"tar" },
  { clue:"Castle echoes", word1:"castle", word2:"echoes", answer:"chortle", tri1:"tle", tri2:"cho" },
  { clue:"Ignite nickel", word1:"ignite", word2:"nickel", answer:"nitpick", tri1:"nit", tri2:"ick" },
  { clue:"Gumboot suction", word1:"gumboot", word2:"suction", answer:"succumb", tri1:"umb", tri2:"suc" },
  { clue:"Kitchen slogan", word1:"kitchen", word2:"slogan", answer:"ganache", tri1:"che", tri2:"gan" },
  { clue:"Airport hordes", word1:"airport", word2:"hordes", answer:"despair", tri1:"air", tri2:"des" },
  { clue:"Toned cowboy", word1:"toned", word2:"cowboy", answer:"jawbone", tri1:"one", tri2:"wbo" },
  { clue:"Genial words", word1:"genial", word2:"words", answer:"cordial", tri1:"ial", tri2:"ord" },
  { clue:"Wildly hungry", word1:"wildly", word2:"hungry", answer:"ungodly", tri1:"dly", tri2:"ung" },
  { clue:"Harsh pencil", word1:"harsh", word2:"pencil", answer:"sharpen", tri1:"har", tri2:"pen" },
  { clue:"Raccoon scuffle!", word1:"raccoon", word2:"scuffle", answer:"buffoon", tri1:"oon", tri2:"uff" },
  { clue:"Silent heels", word1:"silent", word2:"heels", answer:"genteel", tri1:"ent", tri2:"eel" },
  { clue:"Escaped turkey", word1:"escaped", word2:"turkey", answer:"capture", tri1:"cap", tri2:"tur" },
  { clue:"Discard fruit", word1:"discard", word2:"fruit", answer:"biscuit", tri1:"isc", tri2:"uit" },
  { clue:"Upstage comedy?", word1:"upstage", word2:"comedy", answer:"tragedy", tri1:"age", tri2:"edy" },
  { clue:"Sunrise alarm", word1:"sunrise", word2:"alarm", answer:"malaise", tri1:"ise", tri2:"ala" },
  { clue:"Beguile prince", word1:"beguile", word2:"prince", answer:"silence", tri1:"ile", tri2:"nce" },
  { clue:"Awesome pitch!", word1:"awesome", word2:"pitch", answer:"epitome", tri1:"ome", tri2:"pit" },
  { clue:"Husband erred", word1:"husband", word2:"erred", answer:"errands", tri1:"and", tri2:"err" },
  { clue:"Conceal milkman", word1:"conceal", word2:"milkman", answer:"romance", tri1:"nce", tri2:"man" },
  { clue:"Azure outfit", word1:"azure", word2:"outfit", answer:"couture", tri1:"ure", tri2:"out" },
  { clue:"Surveil mobster", word1:"surveil", word2:"mobster", answer:"observe", tri1:"rve", tri2:"obs" },
  { clue:"Storms adobe?", word1:"storms", word2:"adobe", answer:"tornado", tri1:"tor", tri2:"ado" },
  { clue:"Achieve plural?", word1:"achieve", word2:"plural", answer:"several", tri1:"eve", tri2:"ral" },
  { clue:"Grubby tricks", word1:"grubby", word2:"tricks", answer:"rubrics", tri1:"rub", tri2:"ric" },
  { clue:"Marched along", word1:"marched", word2:"along", answer:"echelon", tri1:"che", tri2:"lon" },
  { clue:"Stamina, golly", word1:"stamina", word2:"golly", answer:"finally", tri1:"ina", tri2:"lly" },
  { clue:"Bounty mania", word1:"bounty", word2:"mania", answer:"manhunt", tri1:"unt", tri2:"man" },
  { clue:"Citrus riots!", word1:"citrus", word2:"riots", answer:"vitriol", tri1:"itr", tri2:"rio" },
  { clue:"Market chutney", word1:"market", word2:"chutney", answer:"ketchup", tri1:"ket", tri2:"chu" },
  { clue:"Stolen memory", word1:"stolen", word2:"memory", answer:"history", tri1:"sto", tri2:"ory" },
  { clue:"Funky chicken!", word1:"funky", word2:"chicken", answer:"drunken", tri1:"unk", tri2:"ken" },
  { clue:"Outback erosion", word1:"outback", word2:"erosion", answer:"reroute", tri1:"out", tri2:"ero" },
  { clue:"Whose finery?", word1:"whose", word2:"finery", answer:"hosiery", tri1:"hos", tri2:"ery" },
  { clue:"Crypto babble", word1:"crypto", word2:"babble", answer:"crybaby", tri1:"cry", tri2:"bab" },
  { clue:"Fairly acute", word1:"fairly", word2:"acute", answer:"haircut", tri1:"air", tri2:"cut" },
  { clue:"Anchovy drizzle", word1:"anchovy", word2:"drizzle", answer:"chorizo", tri1:"cho", tri2:"riz" },
  { clue:"Danger, mishaps", word1:"danger", word2:"mishaps", answer:"anguish", tri1:"ang", tri2:"ish" },
  { clue:"Cadet arsenal", word1:"cadet", word2:"arsenal", answer:"grenade", tri1:"ade", tri2:"ena" },
  { clue:"Sworn unique", word1:"sworn", word2:"unique", answer:"unicorn", tri1:"orn", tri2:"uni" },
  { clue:"Extant threat", word1:"extant", word2:"threat", answer:"anthrax", tri1:"ant", tri2:"thr" },
  { clue:"Carbon refills", word1:"carbon", word2:"refills", answer:"careful", tri1:"car", tri2:"ref" },
  { clue:"Laser sighted!", word1:"laser", word2:"sighted", answer:"blasted", tri1:"las", tri2:"ted" },
  { clue:"Nightly affray", word1:"nightly", word2:"affray", answer:"fraught", tri1:"ght", tri2:"fra" },
  { clue:"Slammed pothole", word1:"slammed", word2:"pothole", answer:"mammoth", tri1:"amm", tri2:"oth" },
  { clue:"Granny, please?", word1:"granny", word2:"please", answer:"grapple", tri1:"gra", tri2:"ple" },
  { clue:"Armpit revenge", word1:"armpit", word2:"revenge", answer:"impinge", tri1:"mpi", tri2:"nge" },
  { clue:"Feisty temper", word1:"feisty", word2:"temper", answer:"persist", tri1:"ist", tri2:"per" }

];


const TR = 3;

const el = {
  wrap: document.getElementById('wrap'),
  clue: document.getElementById('clue'),
  gridDock: document.getElementById('gridDock'),
  gridWrap: document.getElementById('gridWrap'),
  grid: document.getElementById('grid'),
  msg: document.getElementById('msg'),
  clueWrap: document.getElementById('clueWrap'),
  hintDockBottom: document.getElementById('hintDockBottom'),
  hintTrack: document.getElementById('hintTrack'),
  trackW1: document.getElementById('trackW1'),
  trackW2: document.getElementById('trackW2'),
  trackExtras: document.getElementById('trackExtras'),
  hintsBtn: document.getElementById('hintsBtn'),
  checkBtn: document.getElementById('checkBtn'),
  btnRow: document.getElementById('btnRow'),
  prevBtn: document.getElementById('prevBtn'),
  nextBtn: document.getElementById('nextBtn'),
  nextPuzzleBtn: document.getElementById('nextPuzzleBtn'),
  skillBadge: document.getElementById('skillBadge'),
  count: document.getElementById('count'),
  kbHost: document.getElementById('kbHost'),
  hintsModal: document.getElementById('hintsModal'),
  hintsModalBody: document.getElementById('hintsModalBody'),
  hintsModalClose: document.getElementById('hintsModalClose'),
  modePill: document.getElementById('modePill'),
  statsBtn: document.getElementById('statsBtn'),
  statsOverlay: document.getElementById('statsOverlay'),
  statsBody: document.getElementById('statsBody'),
  statsClose: document.getElementById('statsClose'),
  helpBtn: document.getElementById('helpBtn'),
  helpOverlay: document.getElementById('helpOverlay'),
  helpClose: document.getElementById('helpClose'),
  modeOverlay: document.getElementById('modeOverlay'),
  modeClose: document.getElementById('modeClose'),
  helpModeLearnMore: document.getElementById('helpModeLearnMore'),
};



const TWOTRI_TEXT   = "Two trigrams from same word";
const OVERLAP_TEXT  = "1-letter overlap allowed ‚úì";
const OVERLAP2_TEXT = "2-letter overlap not allowed";
const HINT_IDS = { w1:'w1', w2:'w2', extras:'extras' };
const HINT_STAGE_ONE_MS = 150 * 1000;
const HINT_STAGE_TWO_MS = 240 * 1000;
const HINT_PINK_CELLS = [1,3,5];

/* =======================
   State
   ======================= */
const state = {
  i: 0,
  finished: false,
  gaveUp: false,

  hintCount: 0,
  hintsUsed: { w1:false, w2:false, extras:false },
  
  assist: false,        // Classic (assist OFF) vs Assisted (assist ON); OFF by default
  assistLocked: false,  // once ON this puzzle, can't be turned OFF (except reset)

  sel1: null,
  sel2: null,

  placed: { w1: null, w2: null },
  singles: [],
  bank: [],
  focusIdx: 0,

  drag: null,

  msgTimer: null,
  msgTransient: false,
  msgTransientEndsAt: 0,
  lockMsg: false,

  // Skill scoring
  cycleCount: 0,
  wrongCheckCount: 0,
  preHint1Cycles: 0,
  postHint1Cycles: 0,
  effortUnits: 0,

  visibleMsAtPuzzleStart: 0,
  visibleMsAtSegmentStart: 0,
  effortAtSegmentStart: 0,
  wrongCheckCountAtSegmentStart: 0,
  wrongCarry: 0,

  // invalid states
  badSet: new Set(),
  badTris: { w1: new Set(), w2: new Set() },
  badRuns: { w1: [], w2: [] },

  twoSet: new Set(),
  twoTris: { w1: new Set(), w2: new Set() },

  ol2Set: new Set(),
  ol2Tris: { w1: new Set(), w2: new Set() },

  exclSet: new Set(),
  exclTris: { w1: new Set(), w2: new Set() },

  overlapMsgOn: false,
  useCustomKB: false,
  modalOpen: false,

  // hint fly
  pendingFly: null,
  flyAttempts: 0,

  lockedLetters: {},
  hintTimelineActive: false,
  hintTimelineStage: 0,
  hintTimelineStart: 0,
  hintStageStartedAt: 0,
  hintPinkSelectable: false,
  hintHighlight: false,
  hintProgressTO: null,
  hintTimer1: null,
  hintTimer2: null,


  // timed reveal (experimental; persisted per puzzle)
  trElapsedMs: 0,
  trStage: 0,
  trPickActive: false,
  trLocked: {},

  // Classic-only: show grid colours only while press-holding a trigram

  classicHoldColors: false,
  classicHoldPending: false,
  classicHoldPointerId: null,
  classicHoldTO: null,
};


/* =======================
   Flags (prebuilt objects; avoids realloc each call)
   ======================= */
const FLAGS_CLASSIC = {
  allowClueTapPlace: false,
  allowClueTapCycle: false,
  allowHintTapPlace: true,
  allowHint3TapInsert: true,
  allowDragTrigrams: true,
  allowAutoPromote: true,
  showGridColors: true,
  showStatusMessages: true,
  showBadCellColor: true,
  checkFeedback: "minimal",
};

/* =======================
   Timed Reveal test mode (scaffolding)
   NOTE: leave OFF until the timer/locked-letter logic is added in later steps.
   ======================= */
const TIMED_REVEAL_MODE = false;

const FLAGS_TIMED_REVEAL = {
  allowClueTapPlace: false,
  allowClueTapCycle: false,
  allowHintTapPlace: false,     // no hint-track interactions in timed mode
  allowHint3TapInsert: false,   // hint3 becomes ‚Äúreveal remaining letter‚Äù later
  allowDragTrigrams: false,
  allowAutoPromote: false,      // critical: avoids promotion removing singles
  showGridColors: true,
  showStatusMessages: true,
  showBadCellColor: true,
  checkFeedback: "minimal",
};

function flags(){
  if(TIMED_REVEAL_MODE) return FLAGS_TIMED_REVEAL;
  return state.assist ? FLAGS_ASSISTED : FLAGS_CLASSIC;
}


/* =======================
   Mode pill (Classic vs Assisted)
   ======================= */
function updateModePill(){
  if(!el.modePill) return;
  const label = state.assist ? "Assisted" : "Classic";
  el.modePill.textContent = label;
  el.modePill.setAttribute("aria-label", `Mode: ${label}`);
}


/* =======================
   Helpers
   ======================= */
function uid(){ return Math.random().toString(16).slice(2) + Date.now().toString(16); }
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }
function norm(s){ return String(s||"").toLowerCase().replace(/[^a-z]/g,""); }
function isAlpha(ch){ return /^[a-z]$/i.test(ch); }
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

function ensurePuzzleDerived(p){
  if(!p || p._derived) return;

  // Normalised fields cached for speed
  p._ans = norm(p.answer);
  p._n   = clamp(p._ans.length || 7, 6, 8);
  p._startMax = Math.max(0, p._n - TR);

  p._w1 = norm(p.word1);
  p._w2 = norm(p.word2);

  p.tri1 = norm(p.tri1 || "");
  p.tri2 = norm(p.tri2 || "");

  // Allowed trigram sets per word (used by auto-promotion + overlap checks)
  p._allowed = { w1:new Set(), w2:new Set() };
  if(p._w1.length >= TR) for(let i=0;i<=p._w1.length-TR;i++) p._allowed.w1.add(p._w1.slice(i,i+TR));
  if(p._w2.length >= TR) for(let i=0;i<=p._w2.length-TR;i++) p._allowed.w2.add(p._w2.slice(i,i+TR));

  // Tri positions (used by hint 3 extras)
  if(typeof p.tri1_pos !== "number"){
    p.tri1_pos = (p.tri1 && p._ans.includes(p.tri1)) ? p._ans.indexOf(p.tri1) : 0;
  }
  if(typeof p.tri2_pos !== "number"){
    if(p.tri2 && p._ans.includes(p.tri2)){
      const first = p._ans.indexOf(p.tri2);
      const second = p._ans.indexOf(p.tri2, first + 1);
      p.tri2_pos = first;
      if(p.tri1 && p.tri2 && first === p.tri1_pos && second !== -1) p.tri2_pos = second;
    }else{
      p.tri2_pos = 0;
    }
  }

  p._derived = true;
}

function current(){
  const p = PUZZLES[state.i];
  ensurePuzzleDerived(p);
  return p;
}
function getN(){ return current()._n; }
function startMax(){ return current()._startMax; }

function renderSmart(){
  render(!state.useCustomKB);

  // Persist in-progress state 
  if(!state.finished && !state.drag){
    const hasTimedRevealState =
      !!(state.trStage || state.trElapsedMs || state.trPickActive) ||
      (state.trLocked && typeof state.trLocked === "object" && Object.keys(state.trLocked).length);

    const meaningful =
      !!state.assist ||
      !!(state.hintsUsed && (state.hintsUsed.w1 || state.hintsUsed.w2 || state.hintsUsed.extras)) ||
      !!(state.placed && (state.placed.w1 || state.placed.w2)) ||
      !!(state.singles && state.singles.length) ||
      hasTimedRevealState;

    if(meaningful) saveInProgressForCurrentPuzzle();
  }
}



/* =======================
   Visible-time stopwatch
   ======================= */
let _visibleMsTotal = 0;
let _visibleStartTs = document.hidden ? null : performance.now();
function _visibleOnHide(){
  const now = performance.now();
  if(_visibleStartTs != null){
    _visibleMsTotal += (now - _visibleStartTs);
    _visibleStartTs = null;
  }
}
function _visibleOnShow(){
  if(_visibleStartTs == null) _visibleStartTs = performance.now();
}
document.addEventListener('visibilitychange', ()=>{
  if(document.hidden){
    _visibleOnHide();
    abortDrag();
  }else{
    _visibleOnShow();
  }
}, { passive:true });
function getVisibleMsNow(){
  const now = performance.now();
  return _visibleMsTotal + (_visibleStartTs != null ? (now - _visibleStartTs) : 0);
}

/* =======================
   Skill scoring
   ======================= */
function skillResetForPuzzle(){
  const vNow = getVisibleMsNow();
  state.visibleMsAtPuzzleStart = vNow;
  state.visibleMsAtSegmentStart = vNow;
  state.effortAtSegmentStart = (state.effortUnits || 0);
  state.wrongCheckCountAtSegmentStart = (state.wrongCheckCount || 0);
  state.wrongCarry = 0;
}
function addEffort(units){
  state.effortUnits = (state.effortUnits || 0) + (units || 0);
}
function snapshotGridChars(){
  const n = getN();
  const out = new Array(n);
  for(let i=0;i<n;i++) out[i] = String(cellChar(i) || "").toLowerCase();
  return out;
}
function countEffortFromGridChange(before, after, opts={}){
  const countDeletes = !!opts.countDeletes;
  let units = 0;
  const n = Math.min(before.length, after.length);
  for(let i=0;i<n;i++){
    const b = before[i] || "";
    const a = after[i] || "";
    if(a === b) continue;
    if(!countDeletes && !a) continue;
    units += 1;
  }
  return units;
}
function addEffortFromGridChange(before, opts={}){
  if(!before) return;
  const after = snapshotGridChars();
  const units = countEffortFromGridChange(before, after, opts);
  const base = Number(opts.base || 0);
  const total = base + units;
  if(total > 0) addEffort(total);
}

function skillBandForHints(h){
  if(h <= 0) return { min: 88, max: 100 };
  if(h === 1) return { min: 68, max: 87 };
  if(h === 2) return { min: 48, max: 67 };
  return { min: 30, max: 47 };
}
function skillStartNewSegmentAfterHint(){
  const wrongNow = (state.wrongCheckCount || 0);
  const wrongStart = (state.wrongCheckCountAtSegmentStart || 0);
  const dw = Math.max(0, wrongNow - wrongStart);

  const alpha = 0.5;
  state.wrongCarry = ((state.wrongCarry || 0) + dw) * alpha;

  const vNow = getVisibleMsNow();
  state.visibleMsAtSegmentStart = vNow;
  state.effortAtSegmentStart = (state.effortUnits || 0);
  state.wrongCheckCountAtSegmentStart = wrongNow;
}
function computeFinalSkill(gaveUp){
  if(gaveUp) return { skillRaw: 30, skill: 30 };

  const h = clamp(state.hintCount || 0, 0, 3);
  const { min: bandMin, max: bandMax } = skillBandForHints(h);

  const vNow = getVisibleMsNow();
  const vSeg = (typeof state.visibleMsAtSegmentStart === "number") ? state.visibleMsAtSegmentStart : vNow;
  const dt = Math.max(0, (vNow - vSeg) / 1000);

  const effNow = (state.effortUnits || 0);
  const effSeg = (typeof state.effortAtSegmentStart === "number") ? state.effortAtSegmentStart : 0;

  const BASE_E = Math.max(0, getN() - 2);
  const de = Math.max(0, (effNow - effSeg) - BASE_E);

  const wrongNow = (state.wrongCheckCount || 0);
  const wrongSeg = (typeof state.wrongCheckCountAtSegmentStart === "number") ? state.wrongCheckCountAtSegmentStart : 0;
  const dw = Math.max(0, wrongNow - wrongSeg);

  const wrongEffective = dw + (state.wrongCarry || 0);
  const wrongW = 1.0;

  const Tref = [110, 110, 90, 80];
  const Eref = [30, 30, 26, 19];
  const k    = [0.34,0.31,0.29,0.27];

  const L = (dt / Tref[h]) + (de / Eref[h]) + (wrongW * wrongEffective);
  const span = (bandMax - bandMin);

  const skillRaw = bandMin + span * Math.exp(-k[h] * L);
  const skill = clamp(Math.round(skillRaw), bandMin, bandMax);
  return { skillRaw, skill };
}

/* =======================
   Local storage + stats
   ======================= */
const LS_KEY = "trigramGameStats_v1";
function hasLocalStorage(){
  try{ return typeof window !== "undefined" && !!window.localStorage; }catch(e){ return false; }
}
function loadStatsStore(){
  if(!hasLocalStorage()) return { results:{}, progress:{} };
  try{
    const raw = window.localStorage.getItem(LS_KEY);
    if(!raw) return { results:{}, progress:{} };
    const data = JSON.parse(raw);
    if(!data || typeof data !== "object") return { results:{}, progress:{} };
    if(!data.results || typeof data.results !== "object") data.results = {};
    if(!data.progress || typeof data.progress !== "object") data.progress = {};
    return data;
  }catch(e){
    return { results:{}, progress:{} };
  }
}


function saveStatsStore(data){
  if(!hasLocalStorage()) return;
  try{ window.localStorage.setItem(LS_KEY, JSON.stringify(data)); }catch(e){}
}
function clearAllStats(){
  if(!hasLocalStorage()) return;
  try{ window.localStorage.removeItem(LS_KEY); }catch(e){}
}
function storeResultForCurrentPuzzle(skill, gaveUp){
  if(!hasLocalStorage()) return;
  const data = loadStatsStore();
  const id = String(state.i);

  // Store the finished result
  data.results[id] = {
    puzzleIndex: state.i,
    puzzleNumber: state.i + 1,
    hints: state.hintCount || 0,
    skill: skill,
    mode: state.assist ? "Assisted" : "Classic",
    assistOn: !!state.assist,
    gaveUp: !!gaveUp,
    ts: Date.now()
  };

  // Once it's finished, remove any in-progress state for this puzzle
  if(data.progress && typeof data.progress === "object"){
    delete data.progress[id];
  }

  saveStatsStore(data);
}


function getResultForPuzzle(idx){
  const data = loadStatsStore();
  return data.results[String(idx)] || null;
}
  function getProgressForPuzzle(idx){
  const data = loadStatsStore();
  return (data.progress && data.progress[String(idx)]) || null;
}

/**
 * Save in-progress state for the current puzzle
 */
function saveInProgressForCurrentPuzzle(){
  if(!hasLocalStorage()) return;
  const data = loadStatsStore();
  const id = String(state.i);

  if(!data.progress || typeof data.progress !== "object"){
    data.progress = {};
  }

  // If puzzle is finished ‚Üí clear progress
  if(state.finished){
    delete data.progress[id];
    saveStatsStore(data);
    return;
  }

  // Extract grid letters
  const gridChars = snapshotGridChars();
  const hasAnyLetters = gridChars.some(ch => ch && ch !== "");

  const hasLocked = state.lockedLetters && Object.keys(state.lockedLetters).length > 0;
  const hasTimeline = state.hintTimelineActive || (state.hintTimelineStage > 0);

  // Determine whether we have anything meaningful to save
  const hasTimedRevealState =
    !!(state.trStage || state.trElapsedMs || state.trPickActive) ||
    (state.trLocked && typeof state.trLocked === "object" && Object.keys(state.trLocked).length);

  const somethingToSave =
    hasAnyLetters ||
    state.hintsUsed.w1 ||
    state.hintsUsed.w2 ||
    state.hintsUsed.extras ||
    state.assist ||  // Assist mode on counts as meaningful state
    hasLocked || hasTimeline ||
    hasTimedRevealState;


  if(!somethingToSave){
    // Nothing typed, nothing hinted ‚Üí clear progress
    delete data.progress[id];
    saveStatsStore(data);
    return;
  }

  // Build progress entry
  const n = getN();
  const focus = clamp(state.focusIdx ?? 0, 0, n-1);

  // Skill / penalty metrics snapshot
  const metrics = {
    effortUnits: state.effortUnits || 0,
    wrongCheckCount: state.wrongCheckCount || 0,
    wrongCarry: state.wrongCarry || 0,
    visibleMsAtPuzzleStart:
      (typeof state.visibleMsAtPuzzleStart === "number" ? state.visibleMsAtPuzzleStart : 0),
    visibleMsAtSegmentStart:
      (typeof state.visibleMsAtSegmentStart === "number" ? state.visibleMsAtSegmentStart : 0),
    effortAtSegmentStart:
      (typeof state.effortAtSegmentStart === "number" ? state.effortAtSegmentStart : 0),
    wrongCheckCountAtSegmentStart:
      (typeof state.wrongCheckCountAtSegmentStart === "number" ? state.wrongCheckCountAtSegmentStart : 0),
    };

  // Timed reveal snapshot (wired up in later steps)
  const locked = {};
  if(state.trLocked && typeof state.trLocked === "object"){
    for(const [k,v] of Object.entries(state.trLocked)){
      const idx = parseInt(k, 10);
      if(!Number.isFinite(idx) || idx < 0 || idx >= n) continue;
      const ch = String(v || "").toLowerCase();
      if(ch && isAlpha(ch)) locked[String(idx)] = ch[0];
    }
  }
  const timedReveal = {
    elapsedMs: Math.max(0, Math.round(state.trElapsedMs || 0)),
    stage: clamp(state.trStage || 0, 0, 9),
    pickActive: !!state.trPickActive,
    locked
  };

  data.progress[id] = {

    puzzleIndex: state.i,
    hintsUsed: {
      w1: !!(state.hintsUsed && state.hintsUsed.w1),
      w2: !!(state.hintsUsed && state.hintsUsed.w2),
      extras: !!(state.hintsUsed && state.hintsUsed.extras),
    },
    hintCount: clamp(state.hintCount || 0, 0, 3),
    assistOn: !!state.assist,
    timedReveal,
    grid: gridChars,
    focusIdx: focus,
    lockedLetters: state.lockedLetters || {},
    hintTimeline: {
      active: !!state.hintTimelineActive,
      stage: state.hintTimelineStage || 0,
      start: state.hintTimelineStart || 0,
      stageStart: state.hintStageStartedAt || 0,
      highlight: !!state.hintHighlight,
      pinkSelectable: !!state.hintPinkSelectable,
    },
    metrics,
    ts: Date.now()
  };

  saveStatsStore(data);
}

/**
 * Apply stored in-progress hint + grid state to the current puzzle index.
 * Returns true if anything was applied.
 */
function applyStoredProgressToCurrentPuzzle(){
  const saved = getProgressForPuzzle(state.i);
  if(!saved) return false;

  const p = current();
  const n = getN();

  // Restore hints + mode
  state.hintsUsed = {
    w1: !!(saved.hintsUsed && saved.hintsUsed.w1),
    w2: !!(saved.hintsUsed && saved.hintsUsed.w2),
    extras: !!(saved.hintsUsed && saved.hintsUsed.extras),
  };
  state.hintCount = clamp(saved.hintCount || 0, 0, 3);

  state.assist = !!saved.assistOn;
  state.assistLocked = !!saved.assistOn;

  state.lockedLetters = (saved.lockedLetters && typeof saved.lockedLetters === "object") ? saved.lockedLetters : {};
  state.hintTimelineActive = !!(saved.hintTimeline && saved.hintTimeline.active);
  state.hintTimelineStage = saved.hintTimeline ? (saved.hintTimeline.stage || 0) : 0;
  state.hintTimelineStart = saved.hintTimeline ? (saved.hintTimeline.start || 0) : 0;
  state.hintStageStartedAt = saved.hintTimeline ? (saved.hintTimeline.stageStart || 0) : 0;
  state.hintHighlight = !!(saved.hintTimeline && saved.hintTimeline.highlight);
  state.hintPinkSelectable = !!(saved.hintTimeline && saved.hintTimeline.pinkSelectable);


  // Restore grid letters as singles (no placed trigrams; they can be auto-promoted again if needed)
  state.placed = { w1:null, w2:null };
  state.singles = [];
  const chars = Array.isArray(saved.grid) ? saved.grid : [];

  for(let i=0; i<Math.min(n, chars.length); i++){
    const ch = String(chars[i] || "").toLowerCase();
    if(lockedLetterAt(i)) continue;
    if(ch && isAlpha(ch)){
      state.singles.push({ id: uid(), ch, idx:i });
    }
  }

  const focus = (typeof saved.focusIdx === "number") ? clamp(saved.focusIdx, 0, n-1) : 0;
  state.focusIdx = focus;

  // ---- Restore skill / penalty metrics if present ----
  const m = saved.metrics;
  if(m && typeof m === "object"){
    // effort + wrong-check counters
    state.effortUnits = Number.isFinite(m.effortUnits) ? m.effortUnits : 0;
    state.wrongCheckCount = Number.isFinite(m.wrongCheckCount) ? m.wrongCheckCount : 0;
    state.wrongCarry = Number.isFinite(m.wrongCarry) ? m.wrongCarry : 0;

    const vNow = getVisibleMsNow();
    const vPuzzle =
      (typeof m.visibleMsAtPuzzleStart === "number" ? m.visibleMsAtPuzzleStart : vNow);
    const vSeg =
      (typeof m.visibleMsAtSegmentStart === "number" ? m.visibleMsAtSegmentStart : vPuzzle);

    // If these came from a previous browser session, they may be "in the future"
    // relative to the current visible timer; computeFinalSkill clamps dt>=0 so
    // this just means "no extra time penalty from before this session".
    state.visibleMsAtPuzzleStart = vPuzzle;
    state.visibleMsAtSegmentStart = vSeg;

    state.effortAtSegmentStart =
      Number.isFinite(m.effortAtSegmentStart) ? m.effortAtSegmentStart : state.effortUnits;
    state.wrongCheckCountAtSegmentStart =
      Number.isFinite(m.wrongCheckCountAtSegmentStart)
        ? m.wrongCheckCountAtSegmentStart
        : state.wrongCheckCount;
  }
  // If no metrics: we keep whatever resetAllForPuzzle()/skillResetForPuzzle set up,
  // which is a clean baseline for this puzzle.

  // ---- Restore timed reveal state if present ----
  const tr = saved.timedReveal;
  state.trElapsedMs = (tr && typeof tr.elapsedMs === "number" && Number.isFinite(tr.elapsedMs))
    ? Math.max(0, Math.round(tr.elapsedMs))
    : 0;
  state.trStage = (tr && typeof tr.stage === "number" && Number.isFinite(tr.stage))
    ? clamp(tr.stage, 0, 9)
    : 0;
  state.trPickActive = !!(tr && tr.pickActive);

  state.trLocked = {};
  if(tr && tr.locked && typeof tr.locked === "object"){
    for(const [k,v] of Object.entries(tr.locked)){
      const idx = parseInt(k, 10);
      if(!Number.isFinite(idx) || idx < 0 || idx >= n) continue;
      const ch = String(v || "").toLowerCase();
      if(ch && isAlpha(ch)) state.trLocked[String(idx)] = ch[0];
    }
  }

  updateModePill();
  ensureHintTimersAfterRestore();

  return true;
}



function firstUnplayedPuzzleIndex(){
  const data = loadStatsStore();
  for(let i=0; i<PUZZLES.length; i++){
    if(!data.results || !Object.prototype.hasOwnProperty.call(data.results, String(i))) return i;
  }
  return Math.max(0, PUZZLES.length - 1);
}
function nextIncompletePuzzleIndex(fromIdx){
  // If localStorage is unavailable, fall back to simple forward-only behaviour
  if(!hasLocalStorage()){
    return (fromIdx < PUZZLES.length - 1) ? (fromIdx + 1) : -1;
  }

  const data = loadStatsStore();
  const results = (data && data.results && typeof data.results === "object") ? data.results : {};

  // 1) look forward from current
  for(let i = fromIdx + 1; i < PUZZLES.length; i++){
    if(!Object.prototype.hasOwnProperty.call(results, String(i))) return i;
  }

  // 2) wrap to the start and look up to (but not including) current
  for(let i = 0; i < fromIdx; i++){
    if(!Object.prototype.hasOwnProperty.call(results, String(i))) return i;
  }

  // none left
  return -1;
}

  
function applyStoredResultToCurrentPuzzle(){
  const saved = getResultForPuzzle(state.i);
  if(!saved) return false;

  const p = current();
  const ans = p._ans;
  const n = getN();

  abortDrag();
  state.placed = {w1:null, w2:null};
  state.singles = [];
  for(let i=0;i<n;i++){
    state.singles.push({ id: uid(), ch: ans[i] || "", idx:i });
  }
  state.focusIdx = 0;

  state.finished = true;
  state.gaveUp = !!saved.gaveUp;
  state.hintCount = saved.hints || 0;

  state.assist = !!saved.assistOn;
  state.assistLocked = !!saved.assistOn;
  updateModePill();

  state.lockMsg = false;
  clearMsgTimer();
  setMsg("");

  const line1 = saved.gaveUp ? "You gave up!" : `Correct - ${hintPhraseText(state.hintCount)}!`;
  setResultSkillMsg(line1, saved.skill);

  renderSmart();
  return true;
}

function computeModeStats(modeLabel){
  const data = loadStatsStore();
  const all = Object.values(data.results || {});
  const arr = all.filter(r => r.mode === modeLabel);
  const count = arr.length;
  if (!count) return { count: 0 };

  let sumSkill = 0;
  let bestSkill = 0;

  // sort by timestamp so streaks + ‚Äúrecent 5‚Äù are in play order
  const byTime = arr.slice().sort((a, b) => (a.ts || 0) - (b.ts || 0));
  let bestZeroStreak = 0;
  let currentStreak = 0;
  let zeroHintCount = 0;

  const skills = [];

  for (const r of byTime) {
    const h = clamp(r.hints || 0, 0, 3);
    const s = clamp(r.skill || 0, 0, 100);

    skills.push(s);
    sumSkill += s;
    if (s > bestSkill) bestSkill = s;

    // streak + count only from non-give-up, 0-hint solves
    if (!r.gaveUp && h === 0) {
      zeroHintCount++;
      currentStreak++;
      if (currentStreak > bestZeroStreak) bestZeroStreak = currentStreak;
    } else {
      currentStreak = 0;
    }
  }

  let recentAvg = null;
  if (skills.length){
    const k = Math.min(5, skills.length);
    let recentSum = 0;
    for (let i = skills.length - k; i < skills.length; i++){
      recentSum += skills[i];
    }
    recentAvg = recentSum / k;
  }

  const zeroHintRatePct = Math.round((zeroHintCount / count) * 100);

  return {
    count,
    avgSkill: sumSkill / count,
    bestSkill,
    bestZeroStreak,
    zeroHintCount,
    zeroHintRatePct,
    recentAvg
  };
}


function formatAvg(x, decimals){
  if (typeof x !== "number" || !isFinite(x)) return "‚Äî";
  return x.toFixed(decimals);
}

function totalCompletedCount(){
  const data = loadStatsStore();
  return data.results ? Object.keys(data.results).length : 0;
}

function checkResetParam(){
  try{
    const url = new URL(window.location.href);
    if(!url.searchParams.has("reset")) return;

    // Clear all stored stats/progress
    clearAllStats();

    // Remove the "reset" param from the URL so refreshes don't re-trigger it
    url.searchParams.delete("reset");
    const newSearch = url.searchParams.toString();
    const newUrl = url.pathname + (newSearch ? `?${newSearch}` : "") + url.hash;

    window.history.replaceState({}, document.title, newUrl);
  }catch(e){
    // swallow errors ‚Äì better to fail silently than break init()
  }
}
function checkWelcomeParam(){
  try{
    const url = new URL(window.location.href);
    if(!url.searchParams.has("welcome")) return false;

    // Remove the "welcome" param from the URL so refreshes don't re-trigger it
    url.searchParams.delete("welcome");
    const newSearch = url.searchParams.toString();
    const newUrl = url.pathname + (newSearch ? `?${newSearch}` : "") + url.hash;

    window.history.replaceState({}, document.title, newUrl);
    return true;
  }catch(e){
    // swallow errors ‚Äì better to fail silently than break init()
    return false;
  }
}

function renderStatsView(){
  if (!el.statsBody) return;

  const total    = totalCompletedCount();
  const classic  = computeModeStats("Classic");
  const assisted = computeModeStats("Assisted");

 const titleEl = document.getElementById("statsTitle");
if (titleEl){
  titleEl.textContent = "Your stats";
}


  // Helper to render one mode block
  function modeSection(label, stats){
    if (!stats || !stats.count){
      return `
        <section class="statsSection statsSection-empty">
          <h3 class="modeHeading">
            ${label}
            <span class="modeMeta">(0 played)</span>
          </h3>
          <p class="modeLine modeLine-muted">No puzzles played in this mode yet.</p>
        </section>`;
    }

    const hasRecent =
      stats.count >= 5 &&
      typeof stats.recentAvg === "number" &&
      isFinite(stats.recentAvg);

    const recentText  = hasRecent ? `${formatAvg(stats.recentAvg, 0)} avg` : "‚Äî";
    const recentClass = hasRecent ? "modeValue" : "modeValue modeValue-muted";

    return `
      <section class="statsSection">
        <h3 class="modeHeading">
          ${label}
          <span class="modeMeta">(${stats.count} played)</span>
        </h3>
        <p class="modeLine">
          <span class="modeLabel">Skill:</span>
          <span class="modeValue">
            ${formatAvg(stats.avgSkill, 0)} avg ‚Ä¢ ${stats.bestSkill || "‚Äî"} best
          </span>
        </p>
        <p class="modeLine">
          <span class="modeLabel">0-hint rate:</span>
          <span class="modeValue">${stats.zeroHintRatePct}%</span>
        </p>
        <p class="modeLine">
          <span class="modeLabel">Longest 0-hint streak:</span>
          <span class="modeValue">${stats.bestZeroStreak || 0}</span>
        </p>
        <p class="modeLine">
          <span class="modeLabel">Recent (last 5):</span>
          <span class="${recentClass}">${recentText}</span>
        </p>
      </section>`;
  }

  let html = "";

  if (!total){
    html = `<p class="statsEmpty">Solve a few, then check back here!</p>`;
  } else {
    html += `
      <div class="statsModes">
        ${modeSection("Classic mode", classic)}
        ${modeSection("Assisted mode", assisted)}
      </div>
    `;
  }

  // small footer note
  html += `
    <p class="statsIntro" style="margin-top:12px;font-size:12px;opacity:.65;">
      Stats are stored on this device only.
    </p>
  `;

  el.statsBody.innerHTML = html;
}


function openStats(){
  if(!el.statsOverlay) return;
  el.statsOverlay.classList.add('open');
  el.statsOverlay.setAttribute('aria-hidden', 'false');
  renderStatsView();
}
function closeStats(){
  if(!el.statsOverlay) return;
  el.statsOverlay.classList.remove('open');
  el.statsOverlay.setAttribute('aria-hidden', 'true');
}

function openHelp(){
  if(!el.helpOverlay) return;
  el.helpOverlay.classList.add('open');
  el.helpOverlay.setAttribute('aria-hidden', 'false');
}

function closeHelp(){
  if(!el.helpOverlay) return;
  el.helpOverlay.classList.remove('open');
  el.helpOverlay.setAttribute('aria-hidden', 'true');
}

function openModeInfo(){
  if(!el.modeOverlay) return;
  el.modeOverlay.classList.add('open');
  el.modeOverlay.setAttribute('aria-hidden', 'false');
}

function closeModeInfo(){
  if(!el.modeOverlay) return;
  el.modeOverlay.classList.remove('open');
  el.modeOverlay.setAttribute('aria-hidden', 'true');
}


/* =======================
   UI small helpers
   ======================= */
function shakeGrid(){
  el.gridDock.classList.remove('shake');
  void el.gridDock.offsetWidth;
  el.gridDock.classList.add('shake');
  setTimeout(()=> el.gridDock.classList.remove('shake'), 420);
}
function clearIOSSelection(){
  const sel = window.getSelection && window.getSelection();
  if(!sel) return;
  try{ sel.removeAllRanges(); }catch(_){}
}
function selectionWithinApp(){
  const sel = window.getSelection && window.getSelection();
  if(!sel || sel.rangeCount === 0) return false;

  let n = sel.anchorNode;
  if(!n) return false;
  if(n.nodeType === 3) n = n.parentNode; // text node -> element
  if(!n || !n.closest) return false;

  return !!n.closest('#clue, #gridDock, #gridWrap, #hintTrack, #skillDock, #btnRow, #kbHost, #hintsModal');
}

// Block Safari long-press callouts inside the app
document.addEventListener('contextmenu', (e)=>{
  const t = e.target;
  if(t && t.closest && t.closest('#clue, #gridDock, #gridWrap, #hintTrack, #skillDock, #btnRow, #kbHost, #hintsModal')){
    e.preventDefault();
    clearIOSSelection();
  }
}, {capture:true});

// Block selection starting (this is what triggers the loupe/callout)
document.addEventListener('selectstart', (e)=>{
  const t = e.target;
  if(t && t.closest && t.closest('#clue, #gridDock, #gridWrap, #hintTrack, #skillDock, #btnRow, #kbHost, #hintsModal')){
    e.preventDefault();
    clearIOSSelection();
  }
}, {capture:true});

// If Safari still creates a selection range, nuke it immediately
document.addEventListener('selectionchange', ()=>{
  if(selectionWithinApp()) clearIOSSelection();
});


/* =======================
   Assisted mode toggle (no persistence)
   ======================= */

function setEnhanced(on, renderNow=true, source='auto'){
  const next = !!on;

  // Assisted mode can ONLY be turned ON by explicit user intent.
  if(next && source !== 'user') return;

  // Once locked on this puzzle, can't turn off (except reset).
  if(state.assistLocked && !next && source !== 'reset') return;

  if(state.assist === next) return;

  state.assist = next;
  updateModePill();

  if(next){
    state.assistLocked = true;

    // Persist immediately so a refresh can't revert back to Classic.
    // (Also captures "assist engaged" even before any hints/letters.)
    saveInProgressForCurrentPuzzle();
  }else{
    abortDrag();
    // If reset turns assist off, allow progress to be cleared if nothing else is saved.
    saveInProgressForCurrentPuzzle();
  }

  if(renderNow) renderSmart();
}

function resetEnhancedForNewPuzzle(){
  state.assist = false;
  state.assistLocked = false;
  abortDrag();
  updateModePill();
}

/* =======================
   Messages (simplified: removed unused assist-flash queue system)
   ======================= */
function clearMsgTimer(){
  if(state.msgTimer){ clearTimeout(state.msgTimer); state.msgTimer=null; }
  state.msgTransient = false;
  state.msgTransientEndsAt = 0;
}
function setMsgDirect(text, kind){
  clearMsgTimer();
  el.msg.classList.remove('show','warn','result','assistFlash');
  el.msg.textContent = text || "";
  if(!text) return;
  void el.msg.offsetWidth;
  el.msg.classList.add('show');
  if(kind === 'warn') el.msg.classList.add('warn');
  if(kind === 'result') el.msg.classList.add('result');
}
function setMsg(text, kind){ setMsgDirect(text, kind); }

function setTransientMsgDirect(text, ms=2400, kind=null){
  setMsgDirect(text, kind);
  state.msgTransient = true;
  state.msgTransientEndsAt = performance.now() + ms;

  state.msgTimer = setTimeout(()=>{
    el.msg.classList.remove('show','warn','result','assistFlash');

    el.msg.textContent = "";
    state.msgTimer = null;
    state.msgTransient = false;
    state.msgTransientEndsAt = 0;
  }, ms);
}
function setTransientMsg(text, ms=2400, kind=null){ setTransientMsgDirect(text, ms, kind); }

function clearTransientOnAnyChange(){
  if(state.lockMsg){
    state.lockMsg = false;
    setMsg("");
  }
  if(state.msgTransient){
    el.msg.classList.remove('show','warn','result','assistFlash');
    el.msg.textContent = "";
    clearMsgTimer();
  }
}
function excludedMsgText(){
  const n = (state.exclTris?.w1?.size || 0) + (state.exclTris?.w2?.size || 0);
  return (n >= 2) ? "Your hints excluded these trigrams" : "Your hint excluded this trigram";
}
  /* =======================
   Assist activation flash (clue glow + message)
   ======================= */
function triggerAssistActivationFlash(){
  // --- clue glow ---
  if(el.clue){
    el.clue.classList.remove('assist-glow');
    void el.clue.offsetWidth;          // restart animation reliably
    el.clue.classList.add('assist-glow');
    setTimeout(()=>{ el.clue.classList.remove('assist-glow'); }, 3250);
  }

  // --- message flash ---
  if(!el.msg) return;

  clearMsgTimer();
  el.msg.classList.remove('show','warn','result','assistFlash');
  el.msg.textContent = "Assisted mode activated";
  void el.msg.offsetWidth;
  el.msg.classList.add('assistFlash');

  // keep status messages from immediately overwriting it
  state.msgTransient = true;
  state.msgTransientEndsAt = performance.now() + 4200;

  state.msgTimer = setTimeout(()=>{
    el.msg.classList.remove('show','warn','result','assistFlash');
    el.msg.textContent = "";
    state.msgTimer = null;
    state.msgTransient = false;
    state.msgTransientEndsAt = 0;
  }, 4200);
}


/* =======================
   Modal (kept; lightweight)
   ======================= */
function closeModal(){
  if(!state.modalOpen) return;
  el.hintsModal.classList.remove('open');
  el.hintsModal.setAttribute('aria-hidden', 'true');
  state.modalOpen = false;
  requestAnimationFrame(()=>{ if(!state.useCustomKB && !state.finished) focusCell(state.focusIdx ?? 0); });
}
if(el.hintsModal){
  el.hintsModal.addEventListener('pointerdown', (e)=>{
    if(e.target === el.hintsModal){ e.preventDefault(); e.stopPropagation(); closeModal(); }
  },{passive:false});
}
if(el.hintsModalClose){
  el.hintsModalClose.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); closeModal(); });
}
document.addEventListener('keydown', (e)=>{
  if(!state.modalOpen) return;
  if(e.key === "Escape"){
    e.preventDefault();
    closeModal();
  }else{
    if(e.key && e.key.length === 1) e.preventDefault();
    if(e.key === "Backspace" || e.key === "Delete" || e.key === "Enter") e.preventDefault();
  }
}, {capture:true});

/* =======================
   Clue helpers
   ======================= */
function splitClueTwoWords(clue){
  const s = String(clue||"").trim();
  const m = s.match(/^(\S+)\s+(\S+)\s*$/);
  if(m) return [m[1], m[2]];
  const parts = s.split(/\s+/).filter(Boolean);
  return [parts[0]||"", parts[1]||""];
}
function underlineBySubstrings(token, items){
  const chars = Array.from(token);
  const map=[];
  let clean="";
  for(let i=0;i<chars.length;i++){
    if(/[A-Za-z]/.test(chars[i])){ map.push(i); clean += chars[i].toLowerCase(); }
  }
  if(!clean) return escapeHtml(token);

  const clsAt = new Array(chars.length).fill(null);
  const prio = (cls)=> (cls === "u-red" ? 3 : (cls === "u-w1" || cls === "u-w2" ? 2 : 1));

  for(const it of items){
    const sub = norm(it.sub);
    if(!sub) continue;
    let pos = clean.indexOf(sub);
    while(pos >= 0){
      for(let k=0;k<sub.length;k++){
        const oi = map[pos+k];
        if(oi == null) continue;
        const cur = clsAt[oi];
        if(!cur || prio(it.cls) >= prio(cur)) clsAt[oi] = it.cls;
      }

      const oi0 = map[pos];
      const oi1 = map[pos + sub.length - 1];
      if(oi0 != null && oi1 != null){
        const lo = Math.min(oi0, oi1), hi = Math.max(oi0, oi1);
        for(let j = lo; j <= hi; j++){
          if(chars[j] === "'" || chars[j] === "‚Äô"){
            const cur = clsAt[j];
            if(!cur || prio(it.cls) >= prio(cur)) clsAt[j] = it.cls;
          }
        }
      }
      pos = clean.indexOf(sub, pos + 1);
    }
  }

  let out = "";
  let open = null;
  for(let i=0;i<chars.length;i++){
    const c = chars[i];
    const cls = clsAt[i];
    if(cls !== open){
      if(open) out += "</span>";
      if(cls) out += `<span class="${cls}">`;
      open = cls || null;
    }
    out += escapeHtml(c);
  }
  if(open) out += "</span>";
  return out;
}

/* =======================
   Grid model + focus
   ======================= */
function trigramCells(start){ return [start, start+1, start+2]; }
function gridIndexFromPoint(x,y){
  const els = document.elementsFromPoint ? document.elementsFromPoint(x,y) : [document.elementFromPoint(x,y)];
  for(const n of els){
    if(!n) continue;
    const cell = n.closest ? n.closest('.cell') : null;
    if(cell && cell.dataset && cell.dataset.idx != null){
      const idx = Number(cell.dataset.idx);
      if(Number.isFinite(idx)) return idx;
    }
  }
  return null;
}
function overlapCount(aStart, bStart){
  const a0=aStart, b0=bStart;
  return (a0===b0) ? 3
    : (Math.abs(a0-b0)===1 ? 2
    : (Math.abs(a0-b0)===2 ? 1 : 0));
}
function overlapMatchIdx(aStart, bStart){
  const a = trigramCells(aStart);
  const b = trigramCells(bStart);
  for(const i of a) if(b.includes(i)) return i;
  return null;
}
function trigramAtIndex(idx){
  for(const group of ['w1','w2']){
    const pl = state.placed[group];
    if(!pl) continue;
    if(idx >= pl.start && idx < pl.start + TR){
      return {group, start: pl.start, tri: pl.tri, offset: idx - pl.start};
    }
  }
  return null;
}

function lockedLetterAt(idx){
  if(!state.lockedLetters) return null;
  const ch = state.lockedLetters[idx];
  if(ch == null) return null;
  const s = String(ch || "").trim();
  return s ? s : null;
}
function isHintPinkCell(idx){ return HINT_PINK_CELLS.includes(idx); }
function timedHintActive(){ return !!state.hintTimelineActive; }
function canEditIndex(idx){
  if(lockedLetterAt(idx)) return false;
  if(!timedHintActive()) return true;
  if(state.hintPinkSelectable) return isHintPinkCell(idx);
  return false;
}
function hintPlacementBlocked(){
  const hasLocked = state.lockedLetters && Object.keys(state.lockedLetters).length > 0;
  return timedHintActive() || hasLocked;
}
function singleAt(idx){ return state.singles.find(s => s.idx === idx) || null; }
function cellChar(idx){
  const locked = lockedLetterAt(idx);
  if(locked) return locked;
  const t = trigramAtIndex(idx);
  if(t) return t.tri[t.offset];
  const s = singleAt(idx);
  if(s) return s.ch;
  return "";
}
function removeSinglesInCells(cells){
  const set = new Set(cells);
  state.singles = state.singles.filter(s => !set.has(s.idx));
}
function deleteTrigramGroup(group){
  if(!state.placed[group]) return false;
  const start = state.placed[group].start;
  state.placed[group] = null;
  state.focusIdx = clamp(start, 0, getN()-1);
  return true;
}
function deleteAtIndex(idx){
  if(lockedLetterAt(idx)) return false;
  const t = trigramAtIndex(idx);
  if(t) return deleteTrigramGroup(t.group);
  const s = singleAt(idx);
  if(s){
    state.singles = state.singles.filter(x => x.idx !== idx);
    state.focusIdx = clamp(idx, 0, getN()-1);
    return true;
  }
  return false;
}
function focusCell(idx){
  const n = getN();
  const i = clamp(idx, 0, n-1);
  state.focusIdx = i;
  if(state.useCustomKB) return;

  const inp = el.grid.querySelector(`input[data-idx="${i}"]`);
  if(inp){
    inp.focus({preventScroll:true});
    try{
      const len = inp.value ? inp.value.length : 0;
      inp.setSelectionRange(len, len);
    }catch{}
  }
}

/* =======================
   Grid helpers
   ======================= */
function gridHasExactTrigram(tri){
  const t = norm(tri);
  if(!t || t.length !== 3) return false;
  const n = getN();
  for(let s=0; s<=n-3; s++){
    const a = cellChar(s), b = cellChar(s+1), c = cellChar(s+2);
    if(!a || !b || !c) continue;
    if(((a+b+c).toLowerCase()) === t) return true;
  }
  return false;
}
function updateExtrasHintFade(){
  const row = document.getElementById('trackBox-extras');
  if(!row) return;

  const counts = Object.create(null);
  for(const s of (state.singles || [])){
    const ch = String(s.ch || "").toLowerCase();
    if(!ch) continue;
    counts[ch] = (counts[ch] || 0) + 1;
  }
  const remaining = Object.assign(Object.create(null), counts);

  const letters = row.querySelectorAll('.letter');
  letters.forEach(l => l.classList.remove('is-in-grid'));
  letters.forEach(l=>{
    const ch = String(l.textContent || "").trim().toLowerCase();
    if(remaining[ch] > 0){
      l.classList.add('is-in-grid');
      remaining[ch]--;
    }
  });
}

/* =======================
   Typing
   ======================= */
function nextEditableFrom(startIdx, dir){
  // Trigram cells are now editable too; keep this for any other callers.
  const n = getN();
  return clamp(startIdx, 0, n-1);
}

// If the user edits a cell covered by a placed trigram, dissolve that trigram into singles
// so the edit applies to the intended cell.
function dissolveTrigramsCoveringIndex(idx){
  const n = getN();
  const i = clamp(idx, 0, n-1);

  const groups = [];
  for(const g of ['w1','w2']){
    const pl = state.placed[g];
    if(pl && i >= pl.start && i < pl.start + TR) groups.push(g);
  }
  if(!groups.length) return false;

  const letters = new Map();  // pos -> ch
  const covered = new Set();  // all cells that were part of dissolved trigram(s)

  for(const g of groups){
    const pl = state.placed[g];
    if(!pl) continue;

    const start = pl.start;
    const tri   = String(pl.tri || "");
    state.placed[g] = null;

    for(let k=0;k<TR;k++){
      const pos = start + k;
      covered.add(pos);
      letters.set(pos, tri[k] || "");
    }
  }

  // Remove any singles that might exist under those cells (we'll re-add what we want)
  state.singles = state.singles.filter(s => !covered.has(s.idx));

  // Re-add the remaining letters as singles (except the edited cell),
  // and never create singles under any still-placed trigram (e.g. overlap cases).
  for(const [pos, ch] of letters){
    if(pos === i) continue;
    if(pos < 0 || pos >= n) continue;
    if(!ch) continue;
    if(trigramAtIndex(pos)) continue;
    state.singles.push({ id: uid(), ch: String(ch).toLowerCase(), idx: pos });
  }

  return true;
}

function typeLetterAtIndex(idx, ch){
  const n = getN();
  const i = clamp(idx, 0, n-1);
  const lower = String(ch || "").slice(0,1).toLowerCase();
  if(!isAlpha(lower)) return;
  if(!canEditIndex(i)) return;

  // Capture what was there BEFORE dissolving (for effort scoring correctness)
  const prev = String(cellChar(i) || "").toLowerCase();

  // If typing into a placed trigram, dissolve it first so the edit takes effect.
  dissolveTrigramsCoveringIndex(i);

  if(prev !== lower) addEffort(1);

  // Overwrite any existing single at this idx
  state.singles = state.singles.filter(x => x.idx !== i);
  state.singles.push({ id: uid(), ch: lower, idx: i });

  // Move focus forward by 1 (even if that lands inside a trigram ‚Äî it‚Äôs editable now)
  state.focusIdx = clamp(i + 1, 0, n - 1);
}

function typeLetterIntoGrid(letter){
  if(state.finished) return false;
  if(state.modalOpen) return false;

  const ch = String(letter || "").slice(0,1);
  if(!isAlpha(ch)) return false;

  clearTransientOnAnyChange();

  const n = getN();
  const idx = clamp(state.focusIdx ?? 0, 0, n-1);

  typeLetterAtIndex(idx, ch);
  renderSmart();
  return true;
}

function backspaceAtIndexClassic(i){
  const n = getN();
  let idx = clamp(i ?? (state.focusIdx ?? 0), 0, n-1);
  if(!canEditIndex(idx)) return false;

  // Backspace semantics: if current cell is empty, move left
  if(!cellChar(idx)){
    if(idx === 0) return false;
    idx = idx - 1;
  }

  // If deleting inside any placed trigram(s), dissolve them into singles first
  const groupsToDissolve = [];
  for(const g of ['w1','w2']){
    const pl = state.placed[g];
    if(pl && idx >= pl.start && idx < pl.start + TR) groupsToDissolve.push(g);
  }

  const letters = new Map();     // pos -> ch to re-add as singles
  const covered = new Set();     // cells that were part of dissolved trigram(s)

  for(const g of groupsToDissolve){
    const pl = state.placed[g];
    if(!pl) continue;

    const start = pl.start;
    const tri   = String(pl.tri || "");
    state.placed[g] = null;

    for(let k=0;k<TR;k++){
      const pos = start + k;
      covered.add(pos);
      if(pos === idx) continue;          // this is the ONE letter we‚Äôre deleting
      letters.set(pos, tri[k] || "");
    }
  }

  // Remove singles in dissolved cells (and the deleted cell)
  if(covered.size){
    const kill = new Set(covered);
    kill.add(idx);
    state.singles = state.singles.filter(s => !kill.has(s.idx));
  }else{
    // No trigram dissolve: just delete a single at idx (if present)
    state.singles = state.singles.filter(s => s.idx !== idx);
  }

  // Re-add remaining letters from dissolved trigram(s) as singles,
  // but don't create hidden singles under any still-placed trigram.
  for(const [pos, ch] of letters){
    if(pos < 0 || pos >= n) continue;
    if(!ch) continue;
    if(trigramAtIndex(pos)) continue;
    state.singles.push({ id: uid(), ch: String(ch).toLowerCase(), idx: pos });
  }

  state.focusIdx = clamp(idx, 0, n-1);
  return true;
}

function backspaceAtIndex(i){
  // Classic/unassisted: ALWAYS delete exactly one letter (never delete a whole trigram)
  if(!state.assist) return backspaceAtIndexClassic(i);

  // Assisted: keep existing trigram-delete behaviour
  const n = getN();
  const idx = clamp(i ?? (state.focusIdx ?? 0), 0, n-1);
  if(!canEditIndex(idx)) return false;

  const tHere = trigramAtIndex(idx);
  if(tHere){
    if(idx === tHere.start && tHere.start > 0){
      const left = tHere.start - 1;
      const tLeft = trigramAtIndex(left);
      if(tLeft) deleteTrigramGroup(tLeft.group);
      else if(singleAt(left)) deleteAtIndex(left);
      else state.focusIdx = left;
      return true;
    }
    deleteTrigramGroup(tHere.group);
    return true;
  }

  if(singleAt(idx)){ deleteAtIndex(idx); return true; }
  if(idx === 0) return false;

  if(deleteAtIndex(idx - 1)) return true;
  state.focusIdx = clamp(idx - 1, 0, getN()-1);
  return true;
}

function deleteFromEnd(){
  if(state.finished) return false;
  const n = getN();
  for(let i=n-1;i>=0;i--){
    if(!cellChar(i)) continue;
    return backspaceAtIndex(i); // classic => 1 letter, assisted => trigram delete
  }
  return false;
}


/* =======================
   Typed trigram auto-promotion (Assisted only)
   ======================= */
function allowedSet(group){
  const p = current();
  return p._allowed[group] || new Set();
}
function overlapIsValid(aStart, aTri, bStart, bTri){
  const ol = overlapCount(aStart, bStart);
  if(ol === 0) return true;
  if(ol !== 1) return false;
  const common = overlapMatchIdx(aStart, bStart);
  if(common == null) return false;
  const aCh = aTri[common - aStart];
  const bCh = bTri[common - bStart];
  return aCh === bCh;
}
function candidatesForTyped(group){
  if(state.placed[group]) return [];
  const set = allowedSet(group);
  if(!set.size) return [];

  const n = getN();
  const otherGroup = group==='w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];

  const out=[];
  for(let s=0; s<=n-TR; s++){
    let chars = [];
    let borrowed = 0;
    let ok = true;

    for(let k=0;k<TR;k++){
      const idx = s + k;
      const t = trigramAtIndex(idx);
      if(t){
        if(t.group !== otherGroup){ ok = false; break; }
        borrowed++;
        chars.push(t.tri[t.offset]);
      }else{
        const sn = singleAt(idx);
        if(!sn){ ok = false; break; }
        chars.push(sn.ch);
      }
    }
    if(!ok) continue;
    if(borrowed > 1) continue;

    const tri = chars.join("").toLowerCase();
    if(!set.has(tri)) continue;

    if(other){
      const ol = overlapCount(s, other.start);
      if(ol > 1) continue;
      if(ol === 1 && !overlapIsValid(s, tri, other.start, other.tri)) continue;
      if(borrowed === 1 && ol !== 1) continue;
    }else{
      if(borrowed !== 0) continue;
    }

    out.push({start:s, tri});
  }
  return out;
}
function setMiniHighlightToTri(group, tri){
  const p = current();
  const w = group==='w1' ? p._w1 : p._w2;
  const pos = w.indexOf(tri);
  const maxStart = Math.max(0, w.length - TR);
  if(group==='w1') state.sel1 = (pos >= 0) ? clamp(pos, 0, maxStart) : 0;
  else state.sel2 = (pos >= 0) ? clamp(pos, 0, maxStart) : 0;
}
function promoteTypedCandidate(group, cand){
  if(!cand) return false;
  if(state.placed[group]) return false;

  const otherGroup = group==='w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];
  if(other){
    if(overlapCount(cand.start, other.start) > 1) return false;
    if(!overlapIsValid(cand.start, cand.tri, other.start, other.tri)) return false;
  }

  state.placed[group] = {start: cand.start, tri: cand.tri};
  removeSinglesInCells(trigramCells(cand.start));
  setMiniHighlightToTri(group, cand.tri);
  return true;
}
function autoPromoteTypedTrigrams(){
  if(state.finished) return false;
  if(!flags().allowAutoPromote) return false;

  let changed = false;
  const c1 = candidatesForTyped('w1');
  const c2 = candidatesForTyped('w2');

  let w1Cand = (c1.length === 1) ? c1[0] : null;
  let w2Cand = (c2.length === 1) ? c2[0] : null;

  if(w1Cand && w2Cand){
    if(overlapCount(w1Cand.start, w2Cand.start) > 1) { w1Cand = null; w2Cand = null; }
    else if(!overlapIsValid(w1Cand.start, w1Cand.tri, w2Cand.start, w2Cand.tri)) { w1Cand = null; w2Cand = null; }
  }

  if(w1Cand && w2Cand && !state.placed.w1 && !state.placed.w2){
    state.placed.w1 = {start: w1Cand.start, tri: w1Cand.tri};
    state.placed.w2 = {start: w2Cand.start, tri: w2Cand.tri};
    removeSinglesInCells(trigramCells(w1Cand.start));
    removeSinglesInCells(trigramCells(w2Cand.start));
    setMiniHighlightToTri('w1', w1Cand.tri);
    setMiniHighlightToTri('w2', w2Cand.tri);
    changed = true;
  }else{
    if(w1Cand && !state.placed.w1) if(promoteTypedCandidate('w1', w1Cand)) changed = true;
    if(w2Cand && !state.placed.w2) if(promoteTypedCandidate('w2', w2Cand)) changed = true;
  }
  return changed;
}

/* =======================
   Overlap helpers
   ======================= */
function overlapActiveNow(){
  const a = state.placed.w1, b = state.placed.w2;
  if(!a || !b) return false;
  if(overlapCount(a.start, b.start) !== 1) return false;
  return overlapIsValid(a.start, a.tri, b.start, b.tri);
}
function computeOverlapIdxSet(){
  const a = state.placed.w1, b = state.placed.w2;
  const set = new Set();
  if(!a || !b) return set;
  if(overlapCount(a.start, b.start) !== 1) return set;
  const common = overlapMatchIdx(a.start, b.start);
  if(common == null) return set;
  const aCh = a.tri[common - a.start];
  const bCh = b.tri[common - b.start];
  if(aCh === bCh) set.add(common);
  return set;
}

/* =======================
   Invalid / excluded detection
   ======================= */
function compressMaximalStrings(arr){
  const uniq = Array.from(new Set(arr.filter(Boolean)));
  uniq.sort((a,b)=> b.length - a.length);
  const kept = [];
  for(const s of uniq){
    if(!kept.some(k => k.includes(s))) kept.push(s);
  }
  return kept;
}
function computeMax3Invalid(){
  const n = getN();
  const p = current();
  const w1 = p._w1;
  const w2 = p._w2;

  state.badSet = new Set();
  state.badTris = { w1: new Set(), w2: new Set() };
  const runsW1 = [];
  const runsW2 = [];

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));
  let i=0;

  while(i<n){
    if(!chars[i]){ i++; continue; }
    let j=i;
    while(j<n && chars[j]) j++;
    const len = j - i;

    if(len >= 4){
      const run = chars.slice(i,j).join("").toLowerCase();
      for(let a=0; a<=len-4; a++){
        for(let b=a+4; b<=len; b++){
          const s = run.slice(a,b);
          const inW1 = (w1 && w1.includes(s));
          const inW2 = (w2 && w2.includes(s));
          if(inW1 || inW2){
            const ga = i + a;
            const gb = i + b;
            for(let k=ga;k<gb;k++) state.badSet.add(k);
            for(let t=0; t<=s.length-3; t++){
              const tri = s.slice(t,t+3);
              if(inW1) state.badTris.w1.add(tri);
              if(inW2) state.badTris.w2.add(tri);
            }
            if(inW1) runsW1.push(s);
            if(inW2) runsW2.push(s);
          }
        }
      }
    }
    i = j;
  }

  state.badRuns.w1 = compressMaximalStrings(runsW1);
  state.badRuns.w2 = compressMaximalStrings(runsW2);
}
function computeTwoTrigramsInvalid(){
  const n = getN();
  const p = current();
  const w1 = p._w1;
  const w2 = p._w2;

  state.twoSet = new Set();
  state.twoTris = { w1: new Set(), w2: new Set() };

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));
  const occ = { w1: [], w2: [] };

  for(let s=0; s<=n-3; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri = (chars[s] + chars[s+1] + chars[s+2]).toLowerCase();
    if(w1 && w1.includes(tri)) occ.w1.push({start:s, tri});
    if(w2 && w2.includes(tri)) occ.w2.push({start:s, tri});
  }

  for(const group of ['w1','w2']){
    if(occ[group].length >= 2){
      for(const o of occ[group]){
        state.twoTris[group].add(o.tri);
        for(const k of trigramCells(o.start)) state.twoSet.add(k);
      }
    }
  }
}
function computeHintExcludedTrigrams(){
  state.exclSet = new Set();
  state.exclTris = { w1: new Set(), w2: new Set() };

  const n = getN();
  const p = current();
  const chars = Array.from({length:n}, (_,i)=>cellChar(i));

  function scan(group, wNorm, locked){
    if(!wNorm) return;
    for(let s=0; s<=n-3; s++){
      if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
      const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
      if(locked && tri === locked) continue;
      if(wNorm.includes(tri)){
        state.exclTris[group].add(tri);
        state.exclSet.add(s); state.exclSet.add(s+1); state.exclSet.add(s+2);
      }
    }
  }

  if(state.hintsUsed.w1) scan('w1', p._w1, p.tri1);
  if(state.hintsUsed.w2) scan('w2', p._w2, p.tri2);
}
function computeTwoLetterOverlapInvalid(){
  state.ol2Set = new Set();
  state.ol2Tris = { w1: new Set(), w2: new Set() };

  const n = getN();
  const p = current();
  const w1 = p._w1, w2 = p._w2;
  if(!w1 || !w2) return;

  const set1 = p._allowed.w1;
  const set2 = p._allowed.w2;

  const a = state.placed?.w1;
  const b = state.placed?.w2;
  if(a && b && overlapCount(a.start, b.start) === 2){
    state.ol2Tris.w1.add(a.tri);
    state.ol2Tris.w2.add(b.tri);
    for(const k of trigramCells(a.start)) state.ol2Set.add(k);
    for(const k of trigramCells(b.start)) state.ol2Set.add(k);
  }

  const chars = Array.from({length:n}, (_,i)=>cellChar(i));

  const occW2ByStart = new Map();
  for(let s=0; s<=n-3; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
    if(set2.has(tri)){
      if(!occW2ByStart.has(s)) occW2ByStart.set(s, []);
      occW2ByStart.get(s).push(tri);
    }
  }

  for(let s=0; s<=n-3; s++){
    if(!chars[s] || !chars[s+1] || !chars[s+2]) continue;
    const tri1 = (chars[s]+chars[s+1]+chars[s+2]).toLowerCase();
    if(!set1.has(tri1)) continue;

    for(const s2 of [s-1, s+1]){
      const hits2 = occW2ByStart.get(s2);
      if(!hits2) continue;

      for(const tri2 of hits2){
        state.ol2Tris.w1.add(tri1);
        state.ol2Tris.w2.add(tri2);
        for(const k of trigramCells(s))  state.ol2Set.add(k);
        for(const k of trigramCells(s2)) state.ol2Set.add(k);
      }
    }
  }
}
function recomputeInvalids(){
  computeTwoLetterOverlapInvalid();
  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();
}

/* =======================
   Hint extras letters
   ======================= */
function computeHint3Letters(){
  const n = getN();
  const p = current();
  const ans = p._ans;
  const covered = new Set();

  const t1 = clamp(p.tri1_pos || 0, 0, n-3);
  const t2 = clamp(p.tri2_pos || 0, 0, n-3);
  for(let k=0;k<3;k++) covered.add(t1 + k);
  for(let k=0;k<3;k++) covered.add(t2 + k);

  const leftover = [];
  for(let i=0;i<n;i++) if(!covered.has(i)) leftover.push(ans[i]);
  leftover.sort();
  return leftover;
}
function rebuildBank(){ state.bank = computeHint3Letters().map(ch => ({id: uid(), ch})); }

/* =======================
   Status messages (now assumes invalids already computed by renderGrid)
   ======================= */
function updateStatusMessages(){
  if(state.finished) return;
  if(state.lockMsg) return;
  if(state.msgTransient) return;

  const hasOL2  = state.ol2Set.size > 0;
  const hasMax3 = state.badSet.size > 0;
  const hasTwo  = state.twoSet.size > 0;
  const hasExcl = state.exclSet.size > 0;

  if(hasOL2){ setMsg(OVERLAP2_TEXT, 'warn'); state.overlapMsgOn = false; return; }
  if(hasMax3){ setMsg("Max 3 contiguous letters allowed", "warn"); state.overlapMsgOn = false; return; }
  if(hasTwo){ setMsg(TWOTRI_TEXT, "warn"); state.overlapMsgOn = false; return; }
  if(hasExcl){ setMsg(excludedMsgText(), "warn"); state.overlapMsgOn = false; return; }

  if(el.msg.classList.contains('warn')) setMsg("");

  const hasOverlap = state.assist && overlapActiveNow();
  if(hasOverlap){
    if(el.msg.textContent !== OVERLAP_TEXT || el.msg.classList.contains('warn')) setMsg(OVERLAP_TEXT);
    state.overlapMsgOn = true;
  }else{
    if(state.overlapMsgOn && el.msg.textContent === OVERLAP_TEXT) setMsg("");
    if(!state.assist && el.msg.textContent === OVERLAP_TEXT) setMsg("");
    state.overlapMsgOn = false;
  }
}

/* =======================
   Check logic
   ======================= */
function canEnableCheckNow(){
  const n = getN();
  for(let i=0;i<n;i++) if(!cellChar(i)) return false;
  return true;
}
function countTrigramsInWordCount(attempt, wNorm){
  const n = attempt.length;
  if(!wNorm) return 0;
  let c=0;
  for(let s=0; s<=n-3; s++){
    const tri = attempt.slice(s, s+3);
    if(wNorm.includes(tri)) c++;
  }
  return c;
}
function hintPhraseText(h){
  if(h === 0) return "with no hints";
  if(h === 1) return "with 1 hint";
  return `with ${h} hints`;
}
function setResultSkillMsg(line1, skill){
  clearMsgTimer();
  el.msg.classList.remove('show','warn','result','assistFlash');
  el.msg.innerHTML = `<div class="msgLine">${escapeHtml(line1)}</div>`;

  const badgeVal = document.getElementById('skillBadgeValue');
  if(badgeVal) badgeVal.textContent = String(skill);

  const inner = document.querySelector('#skillBadge .skillBadgeInner');
  if(inner){
    inner.classList.remove('gold','silver','bronze','red');
    const tier = (skill >= 88) ? 'gold' : (skill >= 68) ? 'silver' : (skill >= 48) ? 'bronze' : 'red';
    inner.classList.add(tier);
  }

  const badge = document.getElementById('skillBadge');
  if(badge) badge.setAttribute('aria-label', `Skill ${skill}`);

  void el.msg.offsetWidth;
  el.msg.classList.add('show','result');
}
function onCheck(ev){
  if(state.finished) return;
  if(state.modalOpen) return;
  // When timed-reveal locking is active, ignore accidental taps on Check
  if(timedHintActive() && !canEditIndex(state.focusIdx)){
    ev?.preventDefault();
    return;
  }
  clearTransientOnAnyChange();

  const n = getN();
  if(!canEnableCheckNow()){
    setTransientMsg(`Fill all ${n}`, 1400);
    return;
  }

  // Need invalid sets for detailed feedback & enforcement
  computeMax3Invalid();
  computeTwoTrigramsInvalid();
  computeHintExcludedTrigrams();

  const attempt = Array.from({length:n}, (_,i)=>cellChar(i)).join("").toLowerCase();
  const p = current();
  const ans = p._ans;

  // Correct answer
  if(attempt === ans){
    const res = computeFinalSkill(false);
    setResultSkillMsg(`Correct - ${hintPhraseText(state.hintCount)}!`, res.skill);
    state.finished = true;
    state.gaveUp = false;
    storeResultForCurrentPuzzle(res.skill, false);
    renderSmart();
    return;
  }

  // Wrong answer
  state.wrongCheckCount = (state.wrongCheckCount || 0) + 1;
  shakeGrid();

  // === Minimal feedback (Classic) still gets trigram-use messages ===
  if(flags().checkFeedback === "minimal"){
    const w1Hits = countTrigramsInWordCount(attempt, p._w1);
    const w2Hits = countTrigramsInWordCount(attempt, p._w2);

    let msg = "";
    if(w1Hits === 0 && w2Hits === 0) msg = "You didn‚Äôt use any trigrams";
    else if(w1Hits === 0)            msg = "No trigram from word 1";
    else if(w2Hits === 0)            msg = "No trigram from word 2";

    if(msg){
      state.lockMsg = true;
      setMsg(msg, "warn");
    }else{
      setMsg("");
    }

    renderSmart();
    return;
  }

  // === Detailed feedback (Assisted) ‚Äì unchanged logic ===
  if(state.badSet.size){
    setMsg("Max 3 contiguous letters allowed", "warn");
    renderSmart();
    return;
  }
  if(state.twoSet.size){
    setMsg(TWOTRI_TEXT, "warn");
    renderSmart();
    return;
  }
  if(state.exclSet.size){
    setMsg(excludedMsgText(), "warn");
    renderSmart();
    return;
  }

  const w1Hits = countTrigramsInWordCount(attempt, p._w1);
  const w2Hits = countTrigramsInWordCount(attempt, p._w2);

  let msg = "";
  if(w1Hits === 0 && w2Hits === 0) msg = "You didn‚Äôt use any trigrams";
  else if(w1Hits === 0)            msg = "No trigram from word 1";
  else if(w2Hits === 0)            msg = "No trigram from word 2";
  else if(w1Hits > 1 || w2Hits > 1) msg = TWOTRI_TEXT;

  if(msg){
    state.lockMsg = true;
    setMsg(msg, "warn");
  }else{
    setMsg("");
  }

  renderSmart();
}


/* =======================
   Give up
   ======================= */
function extrasUnlocked(){ return state.hintsUsed.w1 && state.hintsUsed.w2; }
/* =======================
   Classic mode: keep grid white unless press-holding a trigram
   ======================= */
function clearClassicHoldTimer(){
  if(state.classicHoldTO){ clearTimeout(state.classicHoldTO); state.classicHoldTO = null; }
}

function startClassicHold(pointerId){
  if(state.assist) return; // Classic-only

  state.classicHoldPending = true;
  state.classicHoldPointerId = pointerId;
  clearClassicHoldTimer();

  // Delay prevents a quick click/tap from ‚Äúflashing‚Äù the colours
  state.classicHoldTO = setTimeout(()=>{
    state.classicHoldTO = null;
    if(state.assist) return;
    if(!state.classicHoldPending) return;

    if(!state.classicHoldColors){
      state.classicHoldColors = true;
      renderSmart();
    }
  }, 140);
}

function endClassicHold(pointerId){
  // Ignore unrelated pointers (multi-touch / stray events)
  if(state.classicHoldPointerId != null && pointerId != null && pointerId !== state.classicHoldPointerId) return;

  const had = !!state.classicHoldColors;

  state.classicHoldPending = false;
  state.classicHoldPointerId = null;
  clearClassicHoldTimer();
  state.classicHoldColors = false;

  // If dragging, let onDragEnd() do the repaint once.
  if(had && !state.assist && !state.drag) renderSmart();
}

function abortDrag(){
  if(state.drag){
    try{ state.drag.ghost?.remove(); }catch{}
    state.drag = null;
  }

  // Also clear Classic hold-colour state (purely visual)
  clearClassicHoldTimer();
  state.classicHoldPending = false;
  state.classicHoldPointerId = null;
  state.classicHoldColors = false;
}
window.addEventListener('blur', ()=> abortDrag());

// Classic: colours should disappear immediately when the press ends anywhere
window.addEventListener('pointerup', (e)=> endClassicHold(e.pointerId), true);
window.addEventListener('pointercancel', (e)=> endClassicHold(e.pointerId), true);


function revealAnswerGiveUp(){
  if(state.finished) return;

  const p = current();
  const ans = p._ans;
  const n = getN();

  abortDrag();
  state.placed = {w1:null, w2:null};
  state.singles = [];
  for(let i=0;i<n;i++){
    state.singles.push({id: uid(), ch: ans[i] || "", idx:i});
  }
  state.focusIdx = 0;

  const res = computeFinalSkill(true);

  state.finished = true;
  state.gaveUp = true;

  state.lockMsg = false;
  clearMsgTimer();
  setMsg("");

  setResultSkillMsg("You gave up!", res.skill);
  storeResultForCurrentPuzzle(res.skill, true);
  renderSmart();
}

/* =======================
   Hint fly animation (unchanged behaviour)
   ======================= */
function makeSpotLettersHTML(chars, mode){
  const spot = document.createElement('div');
  spot.className = `hintSpot ${mode}`;

  const wrap = document.createElement('div');
  wrap.className = "letters";

  let perLetterClass = "";
  if(mode === "h1") perLetterClass = "sel-w1";
  else if(mode === "h2") perLetterClass = "sel-w2";
  else if(mode === "hex") perLetterClass = "extra";

  for(const ch of chars){
    const d = document.createElement('div');
    d.className = `letter ${perLetterClass}`.trim();
    d.textContent = ch;
    wrap.appendChild(d);
  }

  spot.appendChild(wrap);
  return spot;
}
function hintFlyKeyframes(dx, dy, startScale){
  const SH0 = 'drop-shadow(0 22px 22px rgba(0,0,0,.26))';
  const SH1 = 'drop-shadow(0 14px 14px rgba(0,0,0,.18))';
  const SH2 = 'drop-shadow(0 7px 7px rgba(0,0,0,.11))';
  const SH3 = 'drop-shadow(0 2px 2px rgba(0,0,0,.06))';
  const SH4 = 'drop-shadow(0 0 0 rgba(0,0,0,0))';

  const dx1 = dx * 0.78;
  const dy1 = dy * 0.78;
  const dx2 = dx * 0.93;
  const dy2 = dy * 0.93;

  return [
    { transform: `translate(-50%,-50%) scale(${startScale})`, filter: SH0, opacity: 1, offset: 0.00 },
    { transform: `translate(-50%,-50%) scale(${startScale})`, filter: SH0, opacity: 1, offset: 0.56 },
    { transform: `translate(-50%,-50%) translate3d(${dx1}px, ${dy1}px, 0) scale(1.14)`, filter: SH1, opacity: 1, offset: 0.82 },
    { transform: `translate(-50%,-50%) translate3d(${dx2}px, ${dy2}px, 0) scale(1.03)`, filter: SH2, opacity: 1, offset: 0.92 },
    { transform: `translate(-50%,-50%) translate3d(${dx}px, ${dy}px, 0) scale(1.00)`, filter: SH3, opacity: 1, offset: 0.965 },
    { transform: `translate(-50%,-50%) translate3d(${dx}px, ${dy}px, 0) scale(1.00)`, filter: SH4, opacity: 1, offset: 0.992 },
    { transform: `translate(-50%,-50%) translate3d(${dx}px, ${dy}px, 0) scale(1.00)`, filter: SH4, opacity: 1, offset: 1.00 }
  ];
}
function revealTargetInstant(tEl){
  if(!tEl) return;
  tEl.style.transition = 'none';
  tEl.style.opacity = '';
  requestAnimationFrame(()=> requestAnimationFrame(()=>{ tEl.style.transition = ''; }));
}
function runHintFlyExtrasSequential(targetRow, chars){
  if(!targetRow) return false;
  const targets = Array.from(targetRow.querySelectorAll('.letter'));
  if(!targets.length) return false;

  for(const t of targets) t.style.opacity = "0";

  const overlay = document.createElement('div');
  overlay.className = "hintSpotOverlay";
  document.body.appendChild(overlay);

  const total = Math.min(chars.length, targets.length);
  let idx = 0;

  const flyOne = ()=>{
    if(idx >= total){
      for(const t of targets) revealTargetInstant(t);
      requestAnimationFrame(()=> { try{ overlay.remove(); }catch{} });
      return;
    }

    const ch = chars[idx];
    const tEl = targets[idx];

    const spot = makeSpotLettersHTML([ch], 'hex');
    overlay.appendChild(spot);

    const sr = spot.getBoundingClientRect();
    const tr = tEl.getBoundingClientRect();

    const scx = sr.left + sr.width/2;
    const scy = sr.top + sr.height/2;
    const tcx = tr.left + tr.width/2;
    const tcy = tr.top + tr.height/2;

    let dx = tcx - scx;
    let dy = tcy - scy;
    dx = Math.round(dx * 2) / 2;
    dy = Math.round(dy * 2) / 2;

    const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
    const startScale = coarse ? 2.05 : 2.15;

    const DURATION = 860;
    const anim = spot.animate(hintFlyKeyframes(dx, dy, startScale), {
      duration: DURATION,
      easing: 'cubic-bezier(.14,.88,.22,1)',
      fill: 'forwards'
    });

    const early = setTimeout(()=> revealTargetInstant(tEl), DURATION - 34);

    anim.onfinish = ()=>{
      clearTimeout(early);
      revealTargetInstant(tEl);

      requestAnimationFrame(()=>{
        try{ spot.remove(); }catch{}
        idx++;
        requestAnimationFrame(flyOne);
      });
    };
  };

  requestAnimationFrame(flyOne);
  return true;
}
function runHintFly(kind){
  let target = null;
  let mode = 'hex';
  let chars = [];

  const p = current();

  if(kind === 'w1'){
    target = document.getElementById('trackBox-w1');
    mode = 'h1';
    chars = Array.from(p.tri1);
  }else if(kind === 'w2'){
    target = document.getElementById('trackBox-w2');
    mode = 'h2';
    chars = Array.from(p.tri2);
  }else if(kind === 'extras'){
    const row = document.getElementById('trackBox-extras');
    if(state.bank.length === 0) rebuildBank();
    chars = state.bank.map(t=>t.ch);
    return runHintFlyExtrasSequential(row, chars);
  }

  if(!target || !chars.length) return false;

  target.style.opacity = "0";

  const overlay = document.createElement('div');
  overlay.className = "hintSpotOverlay";

  const spot = makeSpotLettersHTML(chars, mode);
  overlay.appendChild(spot);
  document.body.appendChild(overlay);

  const sr = spot.getBoundingClientRect();
  const tr = target.getBoundingClientRect();

  const scx = sr.left + sr.width/2;
  const scy = sr.top + sr.height/2;
  const tcx = tr.left + tr.width/2;
  const tcy = tr.top + tr.height/2;

  let dx = tcx - scx;
  let dy = tcy - scy;
  dx = Math.round(dx * 2) / 2;
  dy = Math.round(dy * 2) / 2;

  const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
  const startScale = coarse ? 2.05 : 2.15;

  const anim = spot.animate(hintFlyKeyframes(dx, dy, startScale), {
    duration: 860,
    easing: 'cubic-bezier(.14,.88,.22,1)',
    fill: 'forwards'
  });

  anim.onfinish = ()=>{
    target.style.opacity = "1";
    requestAnimationFrame(()=>{ try{ overlay.remove(); }catch{} });
  };

  return true;
}
function scheduleHintFly(kind){
  state.pendingFly = kind;
  state.flyAttempts = 0;

  const tryRun = ()=>{
    if(!state.pendingFly) return;
    state.flyAttempts++;

    updateHintTrackPlacement();

    if(runHintFly(state.pendingFly)){
      state.pendingFly = null;
      state.flyAttempts = 0;
      return;
    }

    if(state.flyAttempts < 6){
      requestAnimationFrame(tryRun);
    }else{
      const map = {w1:'trackBox-w1', w2:'trackBox-w2', extras:'trackBox-extras'};
      const id = map[state.pendingFly]||"";
      const t = document.getElementById(id);

      if(state.pendingFly === 'extras'){
        const row = document.getElementById('trackBox-extras');
        if(row) row.querySelectorAll('.letter').forEach(x => x.style.opacity = "");
      }else{
        if(t) t.style.opacity = "1";
      }

      state.pendingFly = null;
      state.flyAttempts = 0;
    }
  };

  requestAnimationFrame(tryRun);
}

/* =======================
   Drag ghost + drag logic
   ======================= */
function trigramIsRedAtStart(start){
  recomputeInvalids();
  for(const idx of trigramCells(start)){
    if(state.ol2Set.has(idx) || state.badSet.has(idx) || state.twoSet.has(idx) || state.exclSet.has(idx)) return true;
  }
  return false;
}
function makeGhostBox(text, bg){
  const ghost = document.createElement('div');
  ghost.className = "ghost";
  ghost.style.display = "flex";
  ghost.style.alignItems = "center";
  ghost.style.justifyContent = "center";
  ghost.style.borderRadius = "12px";
  ghost.style.border = "4px solid var(--ink)";
  ghost.style.fontWeight = "900";
  ghost.style.fontStyle = "italic";
  ghost.style.textTransform = "lowercase";
  ghost.style.background = bg;
  ghost.textContent = text;
  document.body.appendChild(ghost);
  return ghost;
}
function moveGhost(e){
  if(!state.drag) return;
  state.drag.ghost.style.left = e.clientX + "px";
  state.drag.ghost.style.top = e.clientY + "px";
}
function beginDragWithThreshold(e, startFn){
  const startX = e.clientX, startY = e.clientY;
  let started = false;

  const onMove = (ev)=>{
    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;
    if(!started && (dx*dx + dy*dy) > 144){
      started = true;
      clearTransientOnAnyChange();
      startFn(ev);
    }
    if(started){
      ev.preventDefault();
      onDragMove(ev);
    }
  };
  const onUp = (ev)=>{
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointercancel', onCancel);
    if(started) onDragEnd(ev);
  };
  const onCancel = ()=>{
    window.removeEventListener('pointermove', onMove);
    window.removeEventListener('pointerup', onUp);
    window.removeEventListener('pointercancel', onCancel);
    abortDrag();
    renderSmart();
  };

  window.addEventListener('pointermove', onMove, {passive:false});
  window.addEventListener('pointerup', onUp, {once:true});
  window.addEventListener('pointercancel', onCancel, {once:true});
}
function startDragTrigram(ev, group, tri, idx0, start0){
  if(hintPlacementBlocked()) return;
  // Classic mode: reveal colours while holding/dragging a trigram (no flash delay)
  if(!state.assist){
    clearClassicHoldTimer();
    state.classicHoldPending = true;
    state.classicHoldPointerId = ev.pointerId;
    state.classicHoldColors = true;
  }

  const isRed = trigramIsRedAtStart(start0);

  const bg = isRed ? "var(--bad)" : (group === 'w1' ? "var(--w1)" : "var(--w2)");

  const ghost = makeGhostBox(tri, bg);
  ghost.style.width = "112px";
  ghost.style.height = "40px";
  ghost.style.letterSpacing = ".18em";

  const beforeChars = snapshotGridChars();

  state.drag = {
    kind:'trigram',
    group,
    tri,
    grabOffset: idx0 - start0,
    ghost,
    lastIdx:null,
    beforeChars
  };
  moveGhost(ev);
}
function pairForDragPinnedThenPush(group, desiredStart, idxNow){
  const mine = state.placed[group];
  const otherGroup = group==='w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];
  if(!mine || !other){
    return { mineStart: clamp(desiredStart, 0, startMax()), otherStart: other ? other.start : null };
  }

  const currM = mine.start;
  const currO = other.start;
  const mineLeft = currM <= currO;

  const pointerInsideOther = (idxNow >= currO && idxNow < currO + 3);
  const idxInto = idxNow - currO;
  const olNow = overlapCount(currM, currO);

  const deepPush = pointerInsideOther && (
    mineLeft
      ? (idxInto >= (olNow === 1 ? 1 : 2))
      : (idxInto <= (olNow === 1 ? 1 : 0))
  );

  if(!deepPush){
    let sM = clamp(desiredStart, 0, startMax());
    const sO = currO;

    if(mineLeft){
      const maxNoTouch = sO - 3;
      const overlapStart = sO - 2;
      if(sM > maxNoTouch){
        if(overlapStart >= 0 && overlapStart <= startMax() && overlapIsValid(overlapStart, mine.tri, sO, other.tri)){
          sM = overlapStart;
        } else if(maxNoTouch >= 0){
          sM = maxNoTouch;
        } else {
          sM = currM;
        }
      }
    }else{
      const minNoTouch = sO + 3;
      const overlapStart = sO + 2;
      if(sM < minNoTouch){
        if(overlapStart >= 0 && overlapStart <= startMax() && overlapIsValid(overlapStart, mine.tri, sO, other.tri)){
          sM = overlapStart;
        } else if(minNoTouch <= startMax()){
          sM = minNoTouch;
        } else {
          sM = currM;
        }
      }
    }
    return { mineStart: clamp(sM, 0, startMax()), otherStart: sO };
  }

  let best = null;
  const currOl = olNow;

  for(let sM=0; sM<=startMax(); sM++){
    for(let sO=0; sO<=startMax(); sO++){
      const ol = overlapCount(sM, sO);
      if(ol > 1) continue;
      if(ol === 1 && !overlapIsValid(sM, mine.tri, sO, other.tri)) continue;

      const orderFlip = ((currM <= currO) !== (sM <= sO));

      let cost = 12*Math.abs(sM - desiredStart) + 5*Math.abs(sO - currO) + 2*Math.abs(ol - currOl);
      if(orderFlip) cost += (olNow === 1 ? 2 : 8);
      if(pointerInsideOther && ol === 0) cost -= 1;

      if(best == null || cost < best.cost) best = {cost, sM, sO};
    }
  }

  if(!best) return { mineStart: clamp(desiredStart,0,startMax()), otherStart: currO };
  return { mineStart: best.sM, otherStart: best.sO };
}
function onDragMove(e){
  if(!state.drag) return;
  moveGhost(e);

  const idxNow = gridIndexFromPoint(e.clientX, e.clientY);
  if(idxNow == null) return;
  if(state.drag.lastIdx === idxNow) return;
  state.drag.lastIdx = idxNow;

  const d = state.drag;
  if(d.kind !== 'trigram') return;

  const group = d.group;
  const otherGroup = group==='w1' ? 'w2' : 'w1';

  const mine = state.placed[group];
  const other = state.placed[otherGroup];
  if(!mine) return;

  const rawStart = idxNow - d.grabOffset;
  const desired = clamp(rawStart, 0, startMax());

  if(!other){
    mine.start = desired;
    removeSinglesInCells(trigramCells(mine.start));
    renderSmart();
    return;
  }

  const pair = pairForDragPinnedThenPush(group, desired, idxNow);
  mine.start = pair.mineStart;
  other.start = pair.otherStart;

  removeSinglesInCells(trigramCells(mine.start));
  removeSinglesInCells(trigramCells(other.start));
  renderSmart();
}
function rectDistance(x,y,rect){
  const dx = (x < rect.left) ? (rect.left - x) : (x > rect.right ? x - rect.right : 0);
  const dy = (y < rect.top) ? (rect.top - y) : (y > rect.bottom ? y - rect.bottom : 0);
  return Math.hypot(dx,dy);
}
function onDragEnd(e){
  if(!state.drag) return;
  const d = state.drag;
  const before = d.beforeChars;

  try{ d.ghost.remove(); }catch{}
  state.drag = null;

  const rect = el.gridWrap.getBoundingClientRect();
  const dist = rectDistance(e.clientX, e.clientY, rect);
  const REMOVE_DIST = 150;

  if(dist > REMOVE_DIST){
    deleteTrigramGroup(d.group);
  }

  addEffortFromGridChange(before, { countDeletes:true, base:0.5 });
  renderSmart();
}

/* =======================
   Underline logic
   ======================= */
function errorItemsForGroup(group){
  if(state.badRuns[group] && state.badRuns[group].length){
    return state.badRuns[group].map(s => ({sub:s, cls:"u-red"}));
  }
  if(state.ol2Tris[group] && state.ol2Tris[group].size){
    return Array.from(state.ol2Tris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  if(state.twoTris[group] && state.twoTris[group].size){
    return Array.from(state.twoTris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  if(state.exclTris[group] && state.exclTris[group].size){
    return Array.from(state.exclTris[group]).map(t => ({sub:t, cls:"u-red"}));
  }
  return [];
}
function inferredSingleTrigram(group){
  const n = getN();
  const p = current();
  const w = (group === 'w1') ? p._w1 : p._w2;
  if(!w) return null;

  let seen = null;
  for(let s=0; s<=n-3; s++){
    const a = cellChar(s), b = cellChar(s+1), c = cellChar(s+2);
    if(!a || !b || !c) continue;
    const tri = (a+b+c).toLowerCase();
    if(!w.includes(tri)) continue;
    if(seen == null) seen = tri;
    else if(seen !== tri) return null; // early-out (more than one unique)
  }
  return seen;
}
function triForClue(group){
  const pl = state.placed[group];
  if(pl && pl.tri) return pl.tri;
  return inferredSingleTrigram(group);
}

/* =======================
   Placing / cycling
   ======================= */
function placeTrigram(group, tri, opts = {}){
  if(hintPlacementBlocked()) return false;
  const f = flags();
  if(!f.allowClueTapPlace && !f.allowHintTapPlace) return false;
  if(state.finished) return false;

  const avoidOverlap = !!(opts && opts.avoidOverlap);

  const before = snapshotGridChars();
  clearTransientOnAnyChange();

  const n = getN();
  const t = norm(tri);
  if(!t || t.length !== 3) return false;

  const otherGroup = group === 'w1' ? 'w2' : 'w1';
  const other = state.placed[otherGroup];

  let start = (state.placed[group] ? state.placed[group].start : null);
  const focus = clamp(state.focusIdx ?? 0, 0, n-1);
  const prefStart = clamp(focus, 0, startMax());

  function tryStartsInOrder(){
    const order = [];
    order.push(prefStart);
    for(let d=1; d<=startMax(); d++){
      if(prefStart-d >= 0) order.push(prefStart-d);
      if(prefStart+d <= startMax()) order.push(prefStart+d);
    }
    return order;
  }

  function isStartOK(s, otherPlaced){
    if(!otherPlaced) return true;
    const ol = overlapCount(s, otherPlaced.start);
    if(avoidOverlap){
      // for clue/hint placements, do NOT auto-discover the 1-letter overlap
      return (ol === 0);
    }
    // original behaviour: allow 0 or 1-cell overlap if valid, but never 2+
    if(ol > 1) return false;
    if(ol === 1 && !overlapIsValid(s, t, otherPlaced.start, otherPlaced.tri)) return false;
    return true;
  }

  if(start == null){
    start = null;
    for(const s of tryStartsInOrder()){
      if(!isStartOK(s, other)) continue;
      start = s; break;
    }
    if(start == null){
      setTransientMsg("can‚Äôt place", 1800);
      return false;
    }
  }else{
    if(other && !isStartOK(start, other)){
      start = null;
      for(const s of tryStartsInOrder()){
        if(!isStartOK(s, other)) continue;
        start = s; break;
      }
      if(start == null){
        setTransientMsg("can‚Äôt place", 1800);
        return false;
      }
    }
  }

  state.placed[group] = {start, tri:t};
  removeSinglesInCells(trigramCells(start));
  setMiniHighlightToTri(group, t);

  addEffortFromGridChange(before, { countDeletes:true, base:0.5 });
  return true;
}

function cyclePlacedTrigram(group, opts = {}){
  if(!flags().allowClueTapCycle) return;
  if(state.finished) return;
  if(hintPlacementBlocked()) return;

  const pl = state.placed[group];
  if(!pl) return;

  const p = current();
  const w = (group === 'w1') ? p._w1 : p._w2;
  const maxStart = Math.max(0, w.length - 3);
  if(maxStart === 0) return;

  const countCycle = (opts.countCycle !== false);
  if(countCycle){
    state.cycleCount = (state.cycleCount || 0) + 1;
    if(state.hintsUsed.w1) state.postHint1Cycles = (state.postHint1Cycles || 0) + 1;
    else state.preHint1Cycles = (state.preHint1Cycles || 0) + 1;
  }

  const curTri = norm(pl.tri);
  const curPos = w.indexOf(curTri);
  if(group === 'w1') state.sel1 = (curPos >= 0) ? clamp(curPos, 0, maxStart) : 0;
  else state.sel2 = (curPos >= 0) ? clamp(curPos, 0, maxStart) : 0;

  let s = (group === 'w1' ? state.sel1 : state.sel2);
  if(s == null) s = 0;
  s = (s + 1) % (maxStart + 1);
  if(group === 'w1') state.sel1 = s; else state.sel2 = s;

  const tri = w.slice(s, s+3);
  // Clue taps drive this, so we also avoid auto-overlap here
  placeTrigram(group, tri, { avoidOverlap:true });
}

function firstTrigramOfWord(group){
  const p = current();
  const w = (group === 'w1') ? p._w1 : p._w2;
  if(w.length < 3) return null;
  return w.slice(0, 3);
}

/* =======================
   Hint track UI
   ======================= */
function bindTapReliable(node, fn){
  if(!node) return;
  let last = 0;
  const fire = (e)=>{
    const now = performance.now();
    if(now - last < 260) return;
    last = now;
    try{ fn(e); }catch(err){ console.error(err); }
  };

  node.addEventListener('pointerup', (e)=>{
    if(e.pointerType === 'mouse' && e.button !== 0) return;
    e.preventDefault(); e.stopPropagation();
    fire(e);
  }, {passive:false});

  node.addEventListener('click', (e)=>{
    e.preventDefault(); e.stopPropagation();
    fire(e);
  }, {passive:false});

  node.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter' || e.key === ' '){
      e.preventDefault();
      fire(e);
    }
  });
}
function makeTrigramBlock(tri, cls, labelText, onTap, id){
  const block = document.createElement('div');
  block.className = "trackBlock";

  const box = document.createElement('div');
  box.className = "letters clickable";
  box.setAttribute("aria-label", labelText);
  if(id) box.id = id;

  if(typeof onTap === "function") bindTapReliable(box, onTap);

  for(let i=0;i<tri.length;i++){
    const d = document.createElement('div');
    d.className = "letter " + cls;
    d.textContent = tri[i];
    box.appendChild(d);
  }
  block.appendChild(box);
  return block;
}
function renderHintTrack(){
  const p = current();

  el.trackW1.innerHTML = "";
  el.trackW2.innerHTML = "";
  el.trackExtras.innerHTML = "";

  el.trackW1.style.display = "none";
  el.trackW2.style.display = "none";
  el.trackExtras.style.display = "none";

  if(state.hintTimelineActive){
    return;
  }

  if(state.hintsUsed.w1){
    el.trackW1.appendChild(
      makeTrigramBlock(p.tri1, "sel-w1", "word 1 trigram", ()=>{
        if(state.finished || state.modalOpen) return;
        if(!flags().allowHintTapPlace) return;

        // Avoid auto-discovering the 1-letter overlap when tapping the hint minigrid
        placeTrigram('w1', p.tri1, { avoidOverlap:true });
        renderSmart();
      }, "trackBox-w1")
    );
    const bx1 = el.trackW1.querySelector('#trackBox-w1');
    if(bx1) bx1.classList.toggle('is-in-grid', gridHasExactTrigram(p.tri1));
    el.trackW1.style.display = "";

    if(state.pendingFly === 'w1'){
      const bx = el.trackW1.querySelector('#trackBox-w1');
      if(bx) bx.style.opacity = "0";
    }
  }

  if(state.hintsUsed.w2){
    el.trackW2.appendChild(
      makeTrigramBlock(p.tri2, "sel-w2", "word 2 trigram", ()=>{
        if(state.finished || state.modalOpen) return;
                if(!flags().allowHintTapPlace) return;

        // Same ‚Äúno overlap‚Äù rule for word-2 hint taps
        placeTrigram('w2', p.tri2, { avoidOverlap:true });
        renderSmart();
      }, "trackBox-w2")
    );
    const bx2 = el.trackW2.querySelector('#trackBox-w2');
    if(bx2) bx2.classList.toggle('is-in-grid', gridHasExactTrigram(p.tri2));
    el.trackW2.style.display = "";

    if(state.pendingFly === 'w2'){
      const bx = el.trackW2.querySelector('#trackBox-w2');
      if(bx) bx.style.opacity = "0";
    }
  }

  if(state.hintsUsed.extras){
    if(state.bank.length === 0) rebuildBank();

    const block = document.createElement('div');
    block.className = "trackBlock";

    const row = document.createElement('div');
    row.className = "extrasRow";
    row.id = "trackBox-extras";

    for(const tile of state.bank){
      const box = document.createElement('div');
      box.className = "letters clickable";

      const d = document.createElement('div');
      d.className = "letter extra";
      d.textContent = tile.ch;
      if(state.pendingFly === 'extras') d.style.opacity = "0";

      bindTapReliable(d, ()=>{
        if(state.finished || state.modalOpen) return;
        clearTransientOnAnyChange();
        if(!flags().allowHint3TapInsert) return;


        const n = getN();
        for(let i=0;i<n;i++){
          if(state.placed.w1 && i>=state.placed.w1.start && i<state.placed.w1.start+3) continue;
          if(state.placed.w2 && i>=state.placed.w2.start && i<state.placed.w2.start+3) continue;
          if(singleAt(i)) continue;

          addEffort(1);
          state.singles.push({id: uid(), ch: tile.ch, idx: i});
          state.focusIdx = clamp(i+1,0,n-1);
          renderSmart();
          return;
        }
        setTransientMsg("No blank spot", 2000);
      });

      box.appendChild(d);
      row.appendChild(box);
    }

    block.appendChild(row);
    el.trackExtras.appendChild(block);
    el.trackExtras.style.display = "";
  }

  updateExtrasHintFade();
}


/* =======================
   Clue tap behaviour
   ======================= */
function onClueWordActivate(group){
  if(state.finished || state.modalOpen) return;
  if(group !== 'w1' && group !== 'w2') return;

  clearTransientOnAnyChange();

  // Track whether, on this tap, we *promoted* a typed trigram
  // (from Classic mode) into `state.placed[group]`.
  let promotedFromInferred = false;

  if(!state.placed[group]){
    const inferred = inferredSingleTrigram(group);
    if(inferred){
      const t = norm(inferred);
      const n = getN();
      for(let s=0; s<=n-3; s++){
        const a = cellChar(s), b = cellChar(s+1), c = cellChar(s+2);
        if(!a || !b || !c) continue;
        if(((a+b+c).toLowerCase()) !== t) continue;

        // Promote this existing run as the placed trigram
        state.placed[group] = { start:s, tri:t };
        removeSinglesInCells(trigramCells(s));
        promotedFromInferred = true;
        break;
      }
    }
  }

  if(state.placed[group]){
    if(promotedFromInferred){
      // FIRST tap after switching to assist, with a trigram already in the grid:
      // just highlight the existing trigram, don‚Äôt cycle to the next one yet.
      setMiniHighlightToTri(group, state.placed[group].tri);
      renderSmart();
      return;
    }

    // Normal assist behaviour: clue taps cycle through trigrams for this word.
    cyclePlacedTrigram(group, { countCycle: !state.hintsUsed[group] });
  }else{
    // No existing or inferred trigram ‚Üí place a fresh one, avoiding overlap.
    const p = current();
    let tri = null;
    if(group === 'w1' && state.hintsUsed.w1) tri = p.tri1;
    if(group === 'w2' && state.hintsUsed.w2) tri = p.tri2;
    if(!tri) tri = firstTrigramOfWord(group);
    if(tri){
      // Clue-driven placement should not auto-discover the 1-letter overlap
      placeTrigram(group, tri, { avoidOverlap:true });
    }
  }

  renderSmart();
}


(function bindClueTap(){
  if(!el.clue) return;

  let lastActionAt = 0;
  let handledPointerAt = 0;

  const handler = (e, isClick=false)=>{
    if(state.finished || state.modalOpen) return;
    if(!isClick) handledPointerAt = Date.now();
    e.preventDefault();
    e.stopPropagation();

    const w = e.target && e.target.closest ? e.target.closest('.clueWord') : null;
    const group = w ? w.dataset.group : null;

if(!state.assist){
  if(group && !state.placed[group]){
    setEnhanced(true, false, 'user');
    lastActionAt = Date.now();
    onClueWordActivate(group);

    // show assist activation flash AFTER the clue action (so it doesn't get cleared)
    triggerAssistActivationFlash();
    return;
  }

  setEnhanced(true, true, 'user');

  // tapped clue area (or already had a trigram) ‚Äì still show activation flash
  triggerAssistActivationFlash();

  lastActionAt = 0;
  if(!state.useCustomKB) requestAnimationFrame(()=> focusCell(state.focusIdx ?? 0));
  return;
}


    if(!w) return;

    const now = Date.now();
    if(now - lastActionAt < 220) return;
    lastActionAt = now;

    onClueWordActivate(group);
  };

  el.clue.addEventListener('pointerdown', (e)=> handler(e,false), { passive:false, capture:true });
  el.clue.addEventListener('click', (e)=>{
    if(Date.now() - handledPointerAt < 650){ e.preventDefault(); return; }
    handler(e,true);
  }, { passive:false, capture:true });
})();

/* =======================
   Keyboard (custom)
   ======================= */
function shouldUseCustomKB(){
  const coarse = window.matchMedia && window.matchMedia('(pointer:coarse)').matches;
  const small  = window.matchMedia && window.matchMedia('(max-width: 920px)').matches;
  return !!(coarse && small);
}
function setCustomKBEnabled(on){
  state.useCustomKB = !!on;
  document.documentElement.classList.toggle('has-kb', state.useCustomKB);
  buildKeyboard();
  requestAnimationFrame(()=>{
    updateKeyboardHeightVar();
    updateBtnRowHeightVar();
    updateHintTrackPlacement();
  });
}
function updateKeyboardHeightVar(){
  if(!state.useCustomKB) return;
  const rect = el.kbHost.getBoundingClientRect();
  if(rect && rect.height){
    document.documentElement.style.setProperty('--kb-h', `${Math.ceil(rect.height)}px`);
  }
}
function pressKeyAction(kind, val){
  if(state.finished || state.modalOpen) return;
  if(kind === 'letter'){
    typeLetterIntoGrid(val);
  }else if(kind === 'delete'){
    clearTransientOnAnyChange();
    backspaceAtIndex(state.focusIdx ?? 0);
    renderSmart();
  }else if(kind === 'reset'){
    resetMainGridOnly();
  }
}
  // delete-hold repeat (shared across all keys, so it can‚Äôt ‚Äústick‚Äù)
let kbDelTO = null;
let kbDelIV = null;
let kbDelGuardsInstalled = false;

function stopKBDeleteHold(){
  if(kbDelTO){ clearTimeout(kbDelTO); kbDelTO = null; }
  if(kbDelIV){ clearInterval(kbDelIV); kbDelIV = null; }
}

function ensureKBDeleteGuards(){
  if(kbDelGuardsInstalled) return;
  kbDelGuardsInstalled = true;

  // if iOS drops a pointerup, these still kill the repeat
  window.addEventListener('blur', stopKBDeleteHold, {passive:true});
  document.addEventListener('visibilitychange', ()=>{ if(document.hidden) stopKBDeleteHold(); }, {passive:true});
  window.addEventListener('pointerup', stopKBDeleteHold, true);
  window.addEventListener('pointercancel', stopKBDeleteHold, true);
  window.addEventListener('touchend', stopKBDeleteHold, true);
  window.addEventListener('touchcancel', stopKBDeleteHold, true);
}

function makeKey(label, aria, cls, kind, val){
  ensureKBDeleteGuards();

  const b = document.createElement('button');
  b.type = "button";
  b.className = `kbKey ${cls||""}`.trim();
  b.setAttribute('aria-label', aria || label);

  if(kind === 'letter'){
    b.textContent = label;
  }else if(kind === 'reset'){
    b.textContent = "RESET";
  }else if(kind === 'delete'){
    const img = document.createElement('img');
    img.src = 'delete-.svg';
    img.alt = '';
    img.className = 'kbIcon';
    img.setAttribute('aria-hidden', 'true');
    img.draggable = false;
    b.appendChild(img);
  }

  const endHold = (e)=>{
    stopKBDeleteHold();
    try{ b.releasePointerCapture && b.releasePointerCapture(e.pointerId); }catch(_){}
  };

  b.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    e.stopPropagation();
    if(b.classList.contains('is-disabled')) return;

    // critical: ANY key tap cancels any ‚Äústuck‚Äù delete repeat
    stopKBDeleteHold();

    // normal keys: unchanged
    if(kind !== 'delete'){
      pressKeyAction(kind, val);
      return;
    }

    // Delete: one immediately, then repeat while held
    try{ b.setPointerCapture && b.setPointerCapture(e.pointerId); }catch(_){}
    pressKeyAction(kind, val);

    // short initial lag, then steady repeat (your tuned values)
    kbDelTO = setTimeout(()=>{
      kbDelIV = setInterval(()=>{
        if(state.finished || state.modalOpen || b.classList.contains('is-disabled')){
          stopKBDeleteHold();
          return;
        }
        pressKeyAction(kind, val);
      }, 110);
    }, 340);
  }, {passive:false});

  if(kind === 'delete'){
    b.addEventListener('pointerup', endHold, {passive:true});
    b.addEventListener('pointercancel', endHold, {passive:true});
    b.addEventListener('pointerleave', endHold, {passive:true});
    b.addEventListener('lostpointercapture', stopKBDeleteHold, {passive:true});
    b.addEventListener('contextmenu', (e)=>{ e.preventDefault(); }, {passive:false});
  }

  return b;
}


function buildKeyboard(){
  el.kbHost.innerHTML = "";
  if(!state.useCustomKB) return;

  const kb = document.createElement('div');
  kb.className = "kb";

  ["QWERTYUIOP","ASDFGHJKL"].forEach((row)=>{
    const r = document.createElement('div');
    r.className = "kbRow";
    for(const ch of row){
      r.appendChild(makeKey(ch, `Letter ${ch}`, "", "letter", ch.toLowerCase()));
    }
    kb.appendChild(r);
  });

  const r3 = document.createElement('div');
  r3.className = "kbRow";
  r3.appendChild(makeKey("RESET", "Reset", "wide reset", "reset", null));
  for(const ch of "ZXCVBNM"){
    r3.appendChild(makeKey(ch, `Letter ${ch}`, "", "letter", ch.toLowerCase()));
  }
  r3.appendChild(makeKey("DEL", "Delete", "wide delete", "delete", null));
  kb.appendChild(r3);

  el.kbHost.appendChild(kb);

  // tap-near-a-key helper (mobile)
el.kbHost.onpointerdown = (e)=>{
  if(!state.useCustomKB || state.finished || state.modalOpen) return;
  if(e.target && e.target.closest && e.target.closest('.kbKey')) return;

  // prevent iOS selection/zoom gestures from ‚Äúdead space‚Äù taps
  e.preventDefault();

  const keys = Array.from(el.kbHost.querySelectorAll('.kbKey'));
  if(!keys.length) return;

  let best = null;
  for(const k of keys){
    const r = k.getBoundingClientRect();
    const cx = (r.left + r.right)/2;
    const cy = (r.top + r.bottom)/2;
    const dx = e.clientX - cx;
    const dy = e.clientY - cy;
    const d2 = dx*dx + dy*dy;
    if(best == null || d2 < best.d2) best = {k, d2};
  }

  const THRESH = 34;
  if(best && best.d2 <= THRESH*THRESH){
    best.k.dispatchEvent(new PointerEvent('pointerdown', {bubbles:true, cancelable:true, clientX:e.clientX, clientY:e.clientY}));
  }
};


  requestAnimationFrame(()=> updateKeyboardHeightVar());
}

/* =======================
   Hint track placement (TOP vs BOTTOM) ‚Äì removed redundant helpers
   ======================= */
function updateBtnRowHeightVar(){
  const r = el.btnRow?.getBoundingClientRect?.();
  if(r && r.height){
    document.documentElement.style.setProperty('--btn-row-h', `${Math.ceil(r.height)}px`);
  }
}
function updateHintTrackPlacement(){
  const track      = el.hintTrack;
  const topHost    = el.clueWrap;
  const bottomHost = el.hintDockBottom;
  const gridDock   = el.gridDock;
  const btnRow     = el.btnRow;
  if(!track || !topHost || !bottomHost || !gridDock || !btnRow) return;

  const root  = document.documentElement;
  const hasKB = root.classList.contains('has-kb');

  const gridRect  = gridDock.getBoundingClientRect();
  const btnRect   = btnRow.getBoundingClientRect();
  const trackRect = track.getBoundingClientRect();
  if(!gridRect || !btnRect || !trackRect){
    if(track.parentNode !== bottomHost) bottomHost.appendChild(track);
    topHost.classList.remove('hasTopTrack');
    track.classList.remove('hintTrackTop');
    return;
  }

  const available = btnRect.top - gridRect.bottom;
  const MIN_GAP = 80;
  const needTop = hasKB && (available < (trackRect.height + MIN_GAP));
  const currentlyTop = (track.parentNode === topHost);

  if(needTop){
    if(!currentlyTop) topHost.appendChild(track);
    topHost.classList.add('hasTopTrack');
    track.classList.add('hintTrackTop');
  }else{
    if(currentlyTop || track.parentNode !== bottomHost) bottomHost.appendChild(track);
    topHost.classList.remove('hasTopTrack');
    track.classList.remove('hintTrackTop');
  }
}
window.addEventListener('resize', ()=> requestAnimationFrame(updateHintTrackPlacement), {passive:true});
if(window.visualViewport){
  window.visualViewport.addEventListener('resize', ()=> requestAnimationFrame(updateHintTrackPlacement), {passive:true});
}

/* =======================
   RESET main grid only (keyboard RESET)
   ======================= */
function resetMainGridOnly(){
  if(state.modalOpen) return;
  if(state.finished) return;

  clearTransientOnAnyChange();
  abortDrag();

  state.placed = { w1:null, w2:null };
  state.singles = [];
  state.focusIdx = 0;

  // Persist (or clear) progress immediately for this puzzle
  saveInProgressForCurrentPuzzle();

  renderSmart();
  if(!state.useCustomKB) requestAnimationFrame(()=> focusCell(0));
}


/* =======================
   Render grid
   ======================= */
function renderGrid(stealFocus=true){
  const n = getN();
  const f = flags();
  const revealed = state.finished;

  if(!revealed && f.allowAutoPromote){
    for(let k=0;k<2;k++){
      if(!autoPromoteTypedTrigrams()) break;
    }
  }

  // single recompute pass used by BOTH grid colouring + clue underline + status messages
  recomputeInvalids();

  const showColorsNow = (!revealed && f.showGridColors && (state.assist || state.classicHoldColors));
  const overlapSet = showColorsNow ? computeOverlapIdxSet() : new Set();


  el.grid.style.setProperty('--n', String(n));
  el.grid.innerHTML = "";

  for(let i=0;i<n;i++){
    const cell = document.createElement('div');
    cell.className = "cell";
    cell.dataset.idx = String(i);

    if(!revealed && i === clamp(state.focusIdx ?? 0, 0, n-1)){
      cell.classList.add('active');
    }

    const tri = trigramAtIndex(i);
    const locked = lockedLetterAt(i);
    const isPink = isHintPinkCell(i);

    if(!revealed && showColorsNow && tri){
      if(overlapSet.has(i)) cell.classList.add('bg-ol');
      else cell.classList.add(tri.group==='w1' ? 'bg-w1' : 'bg-w2');
    }
    if(!revealed && showColorsNow && f.showBadCellColor && (state.ol2Set.has(i) || state.badSet.has(i) || state.twoSet.has(i) || state.exclSet.has(i))){
      cell.classList.add('bg-bad');
    }

    if(!revealed && f.allowDragTrigrams && tri){
      cell.classList.add('grabbable');
    }

    if(locked) cell.classList.add('locked');
    if(!revealed && isPink) cell.classList.add('hint-pink');
    if(!revealed && state.hintHighlight && isPink) cell.classList.add('hint-highlight');

    const input = document.createElement('input');
    input.type = "text";
    input.inputMode = "none";
    input.autocapitalize = "none";
    input.autocomplete = "off";
    input.autocorrect = "off";
    input.spellcheck = false;
    input.maxLength = 1;
    input.dataset.idx = String(i);
    input.value = cellChar(i);
    input.name = "x-"+i;
    input.enterKeyHint = "done";

    let ro = (!!tri && f.allowAutoPromote) || revealed || state.useCustomKB;
    if(locked) ro = true;
    if(timedHintActive()){
      if(state.hintPinkSelectable){
        ro = ro || !isPink;
      }else{
        ro = true;
      }
    }
    input.readOnly = ro;
    input.tabIndex = state.useCustomKB ? -1 : 0;

    input.addEventListener('focus', ()=>{ state.focusIdx = i; });

    input.addEventListener('keydown', (e)=>{
      if(revealed) return;
      if(state.modalOpen){ e.preventDefault(); return; }

      if(e.key === " " || e.code === "Space" || e.key === "Spacebar"){
        e.preventDefault(); e.stopPropagation();
        clearTransientOnAnyChange();
        focusCell(i + 1);
        renderSmart();
        return;
      }
      if(e.key === "ArrowLeft"){ e.preventDefault(); e.stopPropagation(); clearTransientOnAnyChange(); focusCell(i - 1); renderSmart(); return; }
      if(e.key === "ArrowRight"){ e.preventDefault(); e.stopPropagation(); clearTransientOnAnyChange(); focusCell(i + 1); renderSmart(); return; }

      if(e.key && e.key.length === 1 && isAlpha(e.key) && !input.readOnly){
        e.preventDefault();
        clearTransientOnAnyChange();
        typeLetterAtIndex(i, e.key);
        renderSmart();
        return;
      }

      if(e.key === "Backspace" || e.key === "Delete"){
        e.preventDefault();
        e.stopPropagation();
        clearTransientOnAnyChange();
        backspaceAtIndex(i);
        renderSmart();
        return;
      }

      if(e.key === "Enter"){
        e.preventDefault();
        onCheck();
        return;
      }
    });

    if(!input.readOnly){
      input.addEventListener('input', ()=>{
        if(state.modalOpen) return;
        clearTransientOnAnyChange();
        const v = input.value || "";
        const ch = v.slice(-1);
        if(!ch){ renderSmart(); return; }
        if(!isAlpha(ch)){ input.value = cellChar(i); renderSmart(); return; }
        typeLetterAtIndex(i, ch);
        renderSmart();
      });
    }
    cell.addEventListener('pointerdown', (e)=>{
      if(revealed) return;
      if(state.modalOpen) return;

      state.focusIdx = i;
      if(!state.useCustomKB) requestAnimationFrame(()=> focusCell(i));

      const t = trigramAtIndex(i);

      // Classic: keep grid white unless press-holding a trigram
      if(!state.assist && t){
        startClassicHold(e.pointerId);
      }

      if(f.allowDragTrigrams && t){
        clearTransientOnAnyChange();
        beginDragWithThreshold(e, (ev)=>startDragTrigram(ev, t.group, t.tri, i, t.start));
      }

      renderSmart();
    });


    cell.appendChild(input);
    el.grid.appendChild(cell);
  }

  if(stealFocus && !revealed && !state.useCustomKB && !state.modalOpen){
    requestAnimationFrame(()=> focusCell(state.focusIdx ?? 0));
  }
}

/* =======================
   Hints: sequential button
   ======================= */

function clearHintAutomation(){
  if(state.hintTimer1) clearTimeout(state.hintTimer1);
  if(state.hintTimer2) clearTimeout(state.hintTimer2);
  if(state.hintProgressTO) clearTimeout(state.hintProgressTO);
  state.hintTimer1 = null;
  state.hintTimer2 = null;
  state.hintProgressTO = null;
}
function resetHintAutomation(){
  clearHintAutomation();
  state.hintTimelineActive = false;
  state.hintTimelineStage = 0;
  state.hintTimelineStart = 0;
  state.hintStageStartedAt = 0;
  state.hintPinkSelectable = false;
  state.hintHighlight = false;
  state.lockedLetters = {};
  setHintProgressFill(0);
}
function setHintProgressFill(pct){
  const clamped = clamp(Math.round(pct || 0), 0, 100);
  if(el.hintsBtn) el.hintsBtn.style.setProperty('--hint-fill', `${clamped}%`);
}
function tickHintProgress(){
  if(state.finished){ clearHintAutomation(); return; }
  const now = Date.now();
  let pct = 0;
  if(state.hintTimelineActive){
    if(state.hintTimelineStage >= 2){
      pct = 100;
    }else{
      const stageStart = state.hintStageStartedAt || state.hintTimelineStart || now;
      const dur = (state.hintTimelineStage < 1) ? HINT_STAGE_ONE_MS : HINT_STAGE_TWO_MS;
      pct = clamp(((now - stageStart) / dur) * 100, 0, 100);
    }
  }
  setHintProgressFill(pct);
  updateHintButtonLabel();
  state.hintProgressTO = setTimeout(tickHintProgress, 400);
}
function wipeGridForHint(opts={}){
  const preserveLocked = !!opts.preserveLocked;
  const lockedCopy = preserveLocked ? {...(state.lockedLetters || {})} : {};
  state.placed = { w1:null, w2:null };
  state.singles = [];
  state.bank = [];
  if(preserveLocked){
    state.lockedLetters = lockedCopy;
  }else{
    state.lockedLetters = {};
  }
  state.focusIdx = clamp(HINT_PINK_CELLS[0] || 0, 0, getN()-1);
}
function startHintTimeline(){
  state.hintTimelineActive = true;
  state.hintTimelineStart = Date.now();
  state.hintStageStartedAt = state.hintTimelineStart;
  state.hintTimelineStage = 0;
  state.hintHighlight = false;
  state.hintPinkSelectable = false;

  clearHintAutomation();
  state.hintTimer1 = setTimeout(handleTimedHintStageOne, HINT_STAGE_ONE_MS);
  state.hintTimer2 = setTimeout(handleTimedHintStageTwo, HINT_STAGE_ONE_MS + HINT_STAGE_TWO_MS);
  tickHintProgress();
}
function ensureHintTimersAfterRestore(){
  if(!state.hintTimelineActive) return;
  clearHintAutomation();
  const now = Date.now();
  const start = state.hintTimelineStart || now;
  const elapsed = Math.max(0, now - start);
  if(state.hintTimelineStage < 1){
    const d1 = Math.max(0, HINT_STAGE_ONE_MS - elapsed);
    state.hintTimer1 = setTimeout(handleTimedHintStageOne, d1);
  }
  if(state.hintTimelineStage < 2){
    const target = HINT_STAGE_ONE_MS + HINT_STAGE_TWO_MS;
    const d2 = Math.max(0, target - elapsed);
    state.hintTimer2 = setTimeout(handleTimedHintStageTwo, d2);
  }
  state.hintProgressTO = setTimeout(tickHintProgress, 200);

  if(elapsed >= HINT_STAGE_ONE_MS && state.hintTimelineStage < 1){
    handleTimedHintStageOne();
  }
  if(elapsed >= HINT_STAGE_ONE_MS + HINT_STAGE_TWO_MS && state.hintTimelineStage < 2){
    handleTimedHintStageTwo();
  }
}
function handleTimedHintStageOne(){
  state.hintsUsed.w1 = true;
  state.hintCount = Math.max(state.hintCount || 0, 1);
  state.hintTimelineStage = Math.max(state.hintTimelineStage, 1);
  state.hintStageStartedAt = Date.now();
  state.hintTimer1 = null;
  state.hintHighlight = true;
  state.hintPinkSelectable = false;
  wipeGridForHint({ preserveLocked:true });
  saveInProgressForCurrentPuzzle();
  renderSmart();
}
function handleTimedHintStageTwo(){
  skillStartNewSegmentAfterHint();
  state.hintsUsed.w2 = true;
  state.hintCount = Math.max(state.hintCount || 0, 2);
  state.hintTimelineStage = Math.max(state.hintTimelineStage, 2);
  state.hintStageStartedAt = Date.now();
  state.hintTimer2 = null;
  state.hintHighlight = true;
  state.hintPinkSelectable = true;
  wipeGridForHint({ preserveLocked:true });
  saveInProgressForCurrentPuzzle();
  renderSmart();
}
function revealFinalLockedLetter(){
  const p = current();
  ensurePuzzleDerived(p);
  const ans = p._ans || norm(p.answer);
  for(const idx of HINT_PINK_CELLS){
    if(lockedLetterAt(idx)) continue;
    const ch = ans[idx] || "";
    if(ch){
      state.lockedLetters[idx] = ch;
      break;
    }
  }
  state.hintTimelineActive = false;
  state.hintTimelineStage = Math.max(state.hintTimelineStage, 3);
  state.hintHighlight = true;
  clearHintAutomation();
  setHintProgressFill(100);
}

function nextHintStage(){
  if(!state.hintsUsed.w1) return 1;
  if(!state.hintsUsed.w2) return 2;
  if(!state.hintsUsed.extras) return 3;
  return 4;
}
function updateHintButtonLabel(){
  if(state.finished){
    el.hintsBtn.disabled = true;
    return;
  }
  const st = nextHintStage();
  let label = (st === 1) ? "hint 1" : (st === 2) ? "hint 2" : (st === 3) ? "hint 3" : "give up";

  if(timedHintActive() && st <= 3){
    const now = Date.now();
    const stageStart = state.hintStageStartedAt || state.hintTimelineStart || now;
    const dur = (st === 2) ? HINT_STAGE_ONE_MS : (st === 3 ? HINT_STAGE_TWO_MS : HINT_STAGE_ONE_MS);
    const remaining = Math.max(0, dur - (now - stageStart));
    const sec = Math.round(remaining / 1000);
    label = (st === 3)
      ? `hint 3`
      : `auto hint ${st} (${sec}s)`;
  }

  el.hintsBtn.innerHTML = `<span>${label}</span>`;
}
function applyHint(id){
  if(state.finished) return;

  if(id === HINT_IDS.w1){
    if(state.hintsUsed.w1) return;

    skillStartNewSegmentAfterHint();
    state.hintsUsed.w1 = true;
    state.hintCount = Math.max(state.hintCount || 0, 1);
    startHintTimeline();

    saveInProgressForCurrentPuzzle();
    renderSmart();
    return;
  }

  if(id === HINT_IDS.w2){
    if(state.hintsUsed.w2) return;
    if(!state.hintsUsed.w1) return;
    if(state.hintTimelineStage < 1) return;

    skillStartNewSegmentAfterHint();
    handleTimedHintStageTwo();
    return;
  }

  if(id === HINT_IDS.extras){
    if(state.hintsUsed.extras) return;
    if(state.hintTimelineStage < 2) return;

    skillStartNewSegmentAfterHint();
    state.hintsUsed.extras = true;
    state.hintCount = Math.max(state.hintCount || 0, 3);
    revealFinalLockedLetter();

    saveInProgressForCurrentPuzzle();
    renderSmart();
    return;
  }
}



/* =======================
   Buttons / nav
   ======================= */
function bindFastTap(btn, fn){
  if(!btn) return;
  let last = 0;
  const run = (e)=>{
    const now = Date.now();
    if(e){
      e.preventDefault();
      e.stopPropagation();
    }
    if(now - last < 250) return;
    last = now;
    fn();
  };

  btn.addEventListener('pointerdown', run, {passive:false});
  btn.addEventListener('click', (e)=>{
    if(Date.now() - last < 400){ e.preventDefault(); return; }
    run(e);
  });
}
bindFastTap(el.hintsBtn, ()=>{
  if(state.finished || state.modalOpen) return;
  const st = nextHintStage();
  if(st === 1) applyHint(HINT_IDS.w1);
  else if(st === 2) applyHint(HINT_IDS.w2);
  else if(st === 3) applyHint(HINT_IDS.extras);
  else revealAnswerGiveUp();
});
bindFastTap(el.checkBtn, onCheck);

el.prevBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  if(state.i <= 0) return;

  clearTransientOnAnyChange();
  closeModal();

  // save progress for the puzzle we‚Äôre leaving
  saveInProgressForCurrentPuzzle();

  state.i = state.i - 1;
  resetAllForPuzzle();

  const hadResult = applyStoredResultToCurrentPuzzle();
  if(!hadResult){
    applyStoredProgressToCurrentPuzzle();
  }
  renderSmart();
});

el.nextBtn.addEventListener('click', (e)=>{
  e.preventDefault();
  if(!state.finished) return;
  if(state.i >= PUZZLES.length - 1) return;

  clearTransientOnAnyChange();
  closeModal();

  // save progress for the puzzle we‚Äôre leaving
  saveInProgressForCurrentPuzzle();

  state.i = state.i + 1;
  resetAllForPuzzle();

  const hadResult = applyStoredResultToCurrentPuzzle();
  if(!hadResult){
    applyStoredProgressToCurrentPuzzle();
  }
  renderSmart();
});

if(el.nextPuzzleBtn){
  el.nextPuzzleBtn.addEventListener('click', (e)=>{
    e.preventDefault();
    if(!state.finished) return;

    const target = nextIncompletePuzzleIndex(state.i);
    if(target < 0) return;

    clearTransientOnAnyChange();
    closeModal();

    // save progress for the puzzle we‚Äôre leaving (also clears progress if finished)
    saveInProgressForCurrentPuzzle();

    state.i = target;
    resetAllForPuzzle();

    const hadResult = applyStoredResultToCurrentPuzzle();
    if(!hadResult){
      applyStoredProgressToCurrentPuzzle();
    }
    renderSmart();
  });
}


// Stats button wiring
if(el.statsBtn){
  el.statsBtn.addEventListener('click', (e)=>{ e.preventDefault(); openStats(); });
}
  if(el.skillBadge){
  bindFastTap(el.skillBadge, ()=> openStats());
}
if(el.statsClose){
  el.statsClose.addEventListener('click', (e)=>{ e.preventDefault(); closeStats(); });
}
if(el.statsOverlay){
  el.statsOverlay.addEventListener('click', (e)=>{
    if(e.target === el.statsOverlay){
      e.preventDefault();
      closeStats();
    }
  }, { passive:false });
}

// How-to-play / help button wiring
if(el.helpBtn){
  el.helpBtn.addEventListener('click', (e)=>{ e.preventDefault(); openHelp(); });
}
if(el.helpClose){
  el.helpClose.addEventListener('click', (e)=>{ e.preventDefault(); closeHelp(); });
}
if(el.helpOverlay){
  el.helpOverlay.addEventListener('click', (e)=>{
    if(e.target === el.helpOverlay){
      e.preventDefault();
      closeHelp();
    }
  }, { passive:false });
}

// Mode info wiring
if(el.modePill){
  el.modePill.addEventListener('click', (e)=>{
    e.preventDefault();
    openModeInfo();
  });
}
if(el.modeClose){
  el.modeClose.addEventListener('click', (e)=>{
    e.preventDefault();
    closeModeInfo();
  });
}
if(el.modeOverlay){
  el.modeOverlay.addEventListener('click', (e)=>{
    if(e.target === el.modeOverlay){
      e.preventDefault();
      closeModeInfo();
    }
  }, { passive:false });
}

// "Learn more" inside How to play ‚Üí close help, open mode modal
if(el.helpModeLearnMore){
  el.helpModeLearnMore.addEventListener('click', (e)=>{
    e.preventDefault();
    closeHelp();
    openModeInfo();
  });
}


document.addEventListener('keydown', (e)=>{
  if(state.finished) return;
  if(state.modalOpen) return;

  const target = e.target;
  const inGrid = target && target.closest && target.closest('#gridWrap');

  if(!inGrid && e.key && e.key.length === 1 && isAlpha(e.key)){
    const isOtherTyping = target && target.tagName === "INPUT";
    if(!isOtherTyping){
      e.preventDefault();
      handleKey(e.key.toUpperCase(), true);
    }
  }

  if(e.key === "Backspace" || e.key === "Delete"){
    if(!inGrid || state.useCustomKB){
      e.preventDefault();
      clearTransientOnAnyChange();
      if(deleteFromEnd()) renderSmart();
      return;
    }
  }
});

/* =======================
   Render
   ======================= */

  function setNavDisabled(node, disabled){
  if(!node) return;
  node.classList.toggle('is-disabled', !!disabled);
  node.setAttribute('aria-disabled', disabled ? 'true' : 'false');
  if(disabled) node.setAttribute('tabindex','-1');
  else node.removeAttribute('tabindex');
}

function updateNavButtons(){
  const atFirst = (state.i <= 0);
  const atLast  = (state.i >= PUZZLES.length - 1);

  const nextDisabled = (atLast || !state.finished);

  // prev never loops
  setNavDisabled(el.prevBtn, atFirst);

  // next is blocked until finished, and never loops past last
  setNavDisabled(el.nextBtn, nextDisabled);

  // big solved-state button goes to "next incomplete", so its disabled-state is different
  if(el.nextPuzzleBtn){
    const nextInc = nextIncompletePuzzleIndex(state.i);
    const bigDisabled = (!state.finished || nextInc < 0);

    el.nextPuzzleBtn.disabled = bigDisabled;
    el.nextPuzzleBtn.setAttribute('aria-disabled', bigDisabled ? 'true' : 'false');
  }
}


function render(stealFocus=true){
  const p = current();
  const n = getN();
  el.count.textContent = `${state.i + 1} of ${PUZZLES.length}`;
    updateNavButtons();


  el.wrap.classList.toggle('solved', state.finished);
  el.wrap.classList.toggle('gaveup', state.gaveUp);

  if(state.finished){
    state.hintTimelineActive = false;
    clearHintAutomation();
  }

  renderGrid(stealFocus);

  const [t1, t2] = splitClueTwoWords(p.clue);

  const err1 = errorItemsForGroup('w1');
  const err2 = errorItemsForGroup('w2');

  let a = escapeHtml(t1);
  let b = escapeHtml(t2);

  if(err1.length) a = underlineBySubstrings(t1, err1);
  else{
    const tri1 = triForClue('w1');
    if(tri1) a = underlineBySubstrings(t1, [{sub:tri1, cls:"u-w1"}]);
  }

  if(err2.length) b = underlineBySubstrings(t2, err2);
  else{
    const tri2 = triForClue('w2');
    if(tri2) b = underlineBySubstrings(t2, [{sub:tri2, cls:"u-w2"}]);
  }

  el.clue.innerHTML =
    `<span class="clueWord" data-group="w1">${a}</span> ` +
    `<span class="clueWord" data-group="w2">${b}</span>` +
    `<span class="len">(${n})</span>`;

  renderHintTrack();

  el.checkBtn.classList.toggle('ready', canEnableCheckNow());
  el.checkBtn.disabled = state.finished;

  el.hintsBtn.disabled = state.finished;
  updateHintButtonLabel();

  updateStatusMessages();
}

/* =======================
   Resets + init
   ======================= */
function resetAllForPuzzle(){
  state.finished = false;
  state.gaveUp = false;
  el.wrap.classList.remove('solved','gaveup');

  resetHintAutomation();

  resetEnhancedForNewPuzzle();

  const badgeVal = document.getElementById('skillBadgeValue');
  if(badgeVal) badgeVal.textContent = "‚Äî";

  state.cycleCount = 0;
  state.wrongCheckCount = 0;
  state.preHint1Cycles = 0;
  state.postHint1Cycles = 0;
  state.effortUnits = 0;

  state.hintCount = 0;
  state.hintsUsed = { w1:false, w2:false, extras:false };

  state.bank = [];
  state.pendingFly = null;
  state.flyAttempts = 0;

  state.placed = {w1:null, w2:null};
  state.singles = [];
  state.focusIdx = 0;
  state.sel1 = null;
  state.sel2 = null;

  // timed reveal
  state.trElapsedMs = 0;
  state.trStage = 0;
  state.trPickActive = false;
  state.trLocked = {};

  setMsg("");

  state.overlapMsgOn = false;
  state.lockMsg = false;

  abortDrag();
  skillResetForPuzzle();
}

/* single resize handler (removed duplicate) */
window.addEventListener('resize', ()=>{
  const next = shouldUseCustomKB();
  if(next !== state.useCustomKB) setCustomKBEnabled(next);
  updateKeyboardHeightVar();
}, {passive:true});

/* init */
function init(){
  checkResetParam();
  const showWelcome = checkWelcomeParam();

  state.i = firstUnplayedPuzzleIndex();
  updateModePill();

  setCustomKBEnabled(shouldUseCustomKB());

  resetAllForPuzzle();

  const hadResult = applyStoredResultToCurrentPuzzle();
  if(!hadResult){
    applyStoredProgressToCurrentPuzzle();
  }

  renderSmart();

  if(showWelcome) openHelp();
}



init();
</script>


</body>
</html>
